\subsection{Design and implement a database framework
%a query language and implement a database management 
%system 
that accommodate identified variations}
\label{sec:ro2}

Having an encoding that represent variation we need to incorporate it within the 
database and the query language to allow explicit storing and manipulation of 
variation in a database. Objective 2 aims to design and implement a database framework
that considers variation as a first-class citizen.
% for a variational
%database and variational query language and implement them as 
%a variational database management system that allows users to interact with a
%variational database. 
\tabref{ro2} presents individual research questions we need
to answer for this objective. 

\begin{table}
\caption{Objective 2 research questions.}
\label{tab:ro2}
\centering
\begin{tabularx}{\textwidth}{X}
\toprule
 \textbf{Objective 2: Design and implement a database framework
%  a query language and implement a database management 
%system 
that accommodates identified variations}
\tabularnewline
\midrule
RQ2.1: How should variation in form of feature expression be incorporated in the database as a first-class citizen? (\dbpl, \poly)
\tabularnewline[0.2cm]
RQ2.2: What are appropriate query languages to interact with a database that accounts for variation explicitly? And how should variation in form of feature expression be incorporated in the query language? (\dbpl, \poly)
\tabularnewline[0.2cm]
RQ2.3: Having a theoretical database framework that accounts for variation explicitly, how 
should we implement a database management system that uses that framework? (In progress)
\tabularnewline
\bottomrule
\end{tabularx}
\end{table}


\begin{comment}
* annotations and choices
\end{comment}

For RQ2.1 we annotate elements of a database with feature expression,
as introduced in \secref{encode-var}. 
We use annotated elements both in the schema and content.
Within a schema we allow attributes and relations to exist 
conditionally based on the feature expression assigned to them (\secref{vsch}).
At the content level, we annotate each tuple with a feature expression, indicating when the tuple 
is present (\secref{vtab}). 

\TODO{add def of vdb and what it is conceptually}

\TODO{intro vset first}

\begin{comment}
The variational nature of a VDB requires a query language that
accounts for variation directly.
To express and represent variation in queries,
we incorporate choice calculus~\cite{Walk13thesis, EW11tosem}  into a 
structured query language. We formally define 
\emph{variational relational algebra (VRA)} in \secref{vrel-alg}
as our algebraic query language.
A query written in VRA is called a \emph{variational query (v-query)};
when it is clear from context we use query and v-query interchangeably. 
A v-query typically conveys the same intent over several 
relational database variants, however, a single v-query is also capable of capturing different 
intents over different database variants.
Consequently, the expressiveness of v-queries may cause them to be 
more complicated than relational queries, discussed in \secref{type-sys}. 
Hence, we introduce a 
\emph{type system} for VRA that statically checks if a 
v-query conforms to the underlying v-schema and encoded variability within the VDB.
Finally, we close out this section by providing a set of rules in \secref{var-min} 
for reducing a query's variation.

\end{comment}

For RQ2.2 ...
\TODO{ref to v-rel alg}

\begin{comment}
\end{comment}

For RQ2.3 ...
\TODO{ref impl}

\input{sections/vset}
\input{sections/vsch}
\input{sections/vtab}
\input{sections/vrelAlg}
\input{sections/impl}