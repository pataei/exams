\section{Instances of Variation in Databases}
\label{sec:vardbinstance}


Database researchers have studied several kinds of variation in
both time and space. There is a substantial body of work on \emph{schema
evolution} and \emph{database
migration}~\cite{Prism08Curino,prima08Moon,schEvolUnifyApp,schEvolIssues03Ram},
which corresponds to variation in time. Typically the goal of such work is to
safely migrate existing databases forward to new versions of the schema as it
evolves. 
%
Work on \emph{database versioning}~\cite{datasetVersioning,dbVersioning}
extends this idea to a database's content. In a versioned database, 
%schema and 
content changes can be sent between different instances of a database, similar
to a distributed revision control system.
%
All of this work is different from variational databases because it encodes a
less general notion of variation and does not support querying multiple
versions of the database at once.
%
Work on \emph{data integration} can be viewed as managing variation in
space~\cite{dataIntegBook}. In data integration, the goal is to combine data
from disparate sources and provide a unified interface for querying.
This is different from VDBs, which make differences between variants
explicit. % , which is needed to manage data variation in SPLs.

 The definition of variation is very limited in these problems. Such
 limitation allows for an efficient intelligent solutions, however, it tailors
 their solutions to a specific context and prevents one from using the same
 solution/system in a similar context when variation in time or space appears
 in a database~\cite{schVersioningSurvey95Roddick}. For example, one cannot
 use a data integration system to manage variation in a database used in
 software produced by a SPL.


\subsection{Schema Evolution}
\label{sec:sch-evo}

Current solutions addressing schema evolution rely on
temporal nature of schema evolution. They use timestamps as a 
means to keep track of historical changes either in an external document~\cite{prima08Moon}
or as versions attached to 
databases~\cite{SchEvolRA90McKenzie, schVersioning97Castro, tempSchEvol91Ariav, tsql95Snodgrass}, 
i.e., either approaches fail to incorporate
the timestamps into the database. 
Then, they take one of these approaches:
1) they require the DBA to design a unified schema, map all schema variants
to the unified one, migrate the database variants to the unified schema, and
write queries only on the unified schema~\cite{schEvolUnifyApp},
2) they require the DBA to specify the version for their query and then migrating
all database variants to the queried 
version~\cite{SchEvolRA90McKenzie, schVersioning97Castro, tempSchEvol91Ariav, tsql95Snodgrass},
or 3) they require the user to specify the timestamps for their query and
then reformulate the query for other database variants~\cite{prima08Moon}.


These approaches usually do not
grant users access to old variants of data even if they desire so and it
is messy to keep both different copies of a variant, one with the old schema
and one with the unified schema, since every data addition/update now requires to 
be applied to all copies of the database variant. A better solution
is maintaining a history of the changes applied to the database and the unified schema
as an XML document and providing a language that allows users/developers to choose
the variant they desire~\cite{prima08Moon}. Unfortunately, this is achieved by limiting
the schema evolution to temporal changes, offering a beautifully tailored approach for 
temporal changes, however, resulting in a non-extensible approach for non-temporal changes.

Temporal evolution is tracked by requiring the database to always have a time-related 
attribute in tables. Thus, queries have to specify the time frame for which they are inquiring 
information~\cite{prima08Moon}. 
Now the user can choose a wide enough time frame in their queries to access 
to their desired variant(s). Aside from the detailed mapping of time frames and variants, this
approach requires a query to have one and only one information need, no matter how many
variants it is aiming. That is, if a time frame includes assumingely two variants a user cannot 
write a query that extract two separate information needs for each of them accumulatively 
in one query. Even worse, if this query does not conform to one of the variant's schema
but it conforms to the other one, the query still fails since there is no systematic way to 
identify that the query is ill (does not conform to the schema) for one of the variants. 
These limitations and constraint are the result of ignoring that temporal changes to a 
database is a form of variability.

\subsection{Database Integration}
\label{sec:db-intg}

The need for \emph{data integration} system was raised by the invention of the Internet and 
the World Wide Web which require quick access to lots of data stored online as well
as the ability to query all of them. These systems need to query disparate data sources
which often have different formats (e.g., some are completely structured data while others are 
either semi-structured or unstructured) and have been developed independently of each 
other~\cite{dataIntegBook}.
%Furthermore, there is no gurantee that they have access to 
%
Thus, work on \emph{data integration} can be viewed as managing database variation in
space at the content, schema, and format level.
%Work on \emph{data integration} and \emph{database versioning} can be viewed as
%managing database variation in space~\cite{dataIntegBook}. In data integration,
%the goal is typically to combine data variation from disparate sources and
%provide a unified interface for querying that data. This is different from
%VDBs, which make differences between variants explicit, which is needed to
%manage data variation in SPLs.
%
Most of these systems fall somewhere on the spectrum of warehousing and 
virtual integration. In the warehousing model, data from each source are loaded
and materialized in a physical database called a warehouse whereas
in the virtual integration model, the data remain in each data source and are 
accessed as needed at query time. The VDB framework falls in the middle of 
the spectrum since all database variants (data sources) are stored in a physical database 
without materialization. 

Then, a \emph{mediated schema} is defined for the integrated data and each 
data source has a wrapper/extractor that adjusts the schema and data of the
source to the mediated schema. This is done by using schema matching and 
mapping approaches~\cite{Rahm01Survey,Doan05, schMapBook}. 
Our variational database framework skips this
step since the variational schema contains within itself the variational encoding
of the variants which is similar to the role of  wrapper/extractor in database integration
systems. 

Finally, queries are posed in terms of relations in the mediated schema. Then, they 
are reformulated and optimized to grab part of the data requested by the query from 
the corresponding data source since all data sources do not necessarily contain 
the requested information in the query. Similarly, our SQL generators reformulate a 
variational query to extract data from corresponding variants. However, variational 
queries allow one to select the database variants (or parts of it) that they want to query
whereas queries in a database integration system do not provide such an option. 
Furthermore, unlike VDBs, database integration systems are not variation-preserving, that is, the 
result has no indication as to the belonging of part of data to a specific variant (data source).



\subsection{Temporal Databases and Database Versioning}
\label{sec:db-ver}

There is a rich body of work on temporal databases which consider both the data model and the query language~\cite{tempDataMng, tempDBSurv, tempDBbook}.
These databases manage data that are temporal in nature, that is, the state of the data at a specific
time is important, such as financial and medical data or record-keeping applications. 
%
Some of these databases use traditional database and extend them to meet their 
needs~\cite{stratum,Teradata, db2}, while others adopt an in-database 
approach~\cite{KaufmannMVFKFM13sigmod}.
%
These databases contain attributes indicating the start and end time of either 
the transaction time or the valid time. Temporal query languages usually extend 
traditional query languages by adding timestamps and conditions over 
timestamps ~\cite{chomicki95,Jensen2009,evalTempLang}.
%
Temporal databases only have variation at their content level. Thus, their model is simpler 
than the VDB framework. And similar to VRA, their query languages can express
the desired time frame for extracting data. 


Temporal databases support a linear timeline for a database, however, the rise of collaborative data 
science has led to non-linear time-based changes in a database. 
This resulted in work on database versioning that aims to support curating and analyzing data 
collaboratively~\cite{datahub15cidr}. Inspired by software version control systems such as Git, 
\citet{dbVersioning} introduce \emph{\textsc{OrpheusDB}} which stores metadata information
about the version graph such as 
the version number, its parent(s), checkout time, commit time, comments, etc. 
Using this metadata the shared parts of the database can be breakdown at different scales so
that the database for each version can be recreated.
For example, each version could have a table of its own or 
tuples could have a version attribute and so on. 
\textsc{OrpheusDB} supports both git-style version control 
commands and SQL-like queries. Its query language \emph{VQL} can query the data 
as well as the data and their versions. VQL supports a subset of the query language for 
versioning and provenance proposed by~\citet{vqlAndProv}. 
\citet{datasetVersioning} studies the trade-off of storage and recreation cost for 
different compression and optimization methods used to recreate a database version.
%
Similar to temporal databases, database versioning systems also only contain variation
at the content level. However, their query languages can express git-style commands
whereas VRA cannot. 


%As mentioned in \secref{vtab}, database versioning approaches only consider
%content-level variation~\cite{dbVersioning} which is usually used for experimental and
%scientific databases.
%
%Work on \emph{database versioning}~\cite{datasetVersioning,dbVersioning}
%shifts this idea to content level. In a versioned database, 
%%schema
%%and 
%content changes can be sent between different instances of a database,
%similar to a distributed revision control system.
%%
%All of this work is different from variational databases because it typically
%does not require maintaining or querying multiple versions of the database at
%once.
%

%\subsection{Integrity of Databases}
%\label{sec:integ}
%
%In this section, we highlight the importance of 


