\section{SQL Generator}
\label{sec:apps}


\TODO{if parallel running of queries make a difference add it.}
%
Since VDBMS sits on top of a plain relational DBMS, in order to run
variational queries we must translate them into (sets of) plain relational queries,
that is, \emph{SQL generator} module's task.
These generators also inject the qualifiers of attributes in addition to 
adding the projection of presence condition attributes. We demonstrate this
in \exref{nbf}--\exref{uav}.
Then, VDBMS synthesizes the result into a variational table, that is, 
\emph{variational table builder} module's task.
%
Given an explicitly annotated well-typed variational query \vQ,
%constrained by the schema minimized variation, 
we provide three initial 
approaches to generate SQL query(ies) for \vQ:
\begin{enumerate}
%[wide, labelwidth=!, labelindent=0pt, topsep=1pt]
%\itemsep0em
\item
\emph{Naive Brute Force (\nbf):}
Configures a variational query \vQ\ for all valid configurations, that is, 
\ensuremath{\forall \config \in \confSet}, translates them to RA queries,
and finally generates SQL queries with renaming all subqueries. The 
SQL queries are sent to underlying DBMS and the results are gathered and
cleaned up in variational table builder module. Here is the flow of how results are generated by 
this approach:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\eeSem \vQ}}} [ ( \config, \pQ ) ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{translate}}}_{\mathrm{\textit{to SQL}}}} [ ( \config, \sqlQ ) ]
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{queries}}}} \textit{v-tables}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{v-table}}}_{\mathrm{\textit{builder}}}} \textit{v-table}
\]
%
\begin{example}
\label{eg:nbf}
\wrrite{write the damn thing}
\end{example}
%
\item
\emph{Unique Brute Force (\ubf):}
This approach is just like \nbf\ except that we only generate SQL 
queries for unique RA queries which are the result of configuring the variational query.
That is, it uses the unique variants function \ensuremath{\qGroup \vQ} introduced
in \secref{vraconf}.
%The trick is to attach the condition under which a 
%RA query is valid. This condition is a feature expression generated from
%the set of configurations that configured the variational query into the same RA query, that is,
%\ensuremath{
%\qGroup \vQ = \setDef {\annot \pQ \myOR \forall \config \in \confSet: \fSem \dimMeta = \t,
%\eeSem \vQ = \pQ}
%}. 
The implementation of this function is more efficient than its definition.
%\remember{
%In fact, it follows the function defined in \figref{} in \appref{}.
%}
That is:
%Groups variants of a variational query, translates them to RA queries,
%and generates SQK queries with renaming subqueries. Similar to 
%\ensuremath{(1)} results are gathered and cleaned up by variational table builder module.
%Here is the flow of how results are generated by 
%this approach:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\qGroup \vQ}}} [ \annot [\dimMeta] {\pQ} ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{translate}}}_{\mathrm{\textit{to SQL}}}} [ \annot [\dimMeta] {\sqlQ} ]
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{queries}}}} \textit{v-tables}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{v-table}}}_{\mathrm{\textit{builder}}}} \textit{v-table}
\]
%
\begin{example}
\label{eg:ubf}
\wrrite{write the damn thing}
\end{example}
%
\item
\emph{Union-All-Variants (\uav):}
This approach takes the SQL queries generated by \ubf\ and 
unions them to just run one SQL query. In order to do so it 
forces all the SQL queries to return the same relation schema.
%return the same set of attributes.
Additionally, it applies the presence condition of a SQL query
to its tuples by concating it with the presence condition attribute
in the projected attribute set.
%Groups variants of a variational query, translates them to RA queries, 
%translates RA queries to SQL queries, 
%%generates one SQL query from all SQL queries by u
%unifies the set of
%attributes returned by SQL queries (by getting all returned attributes from
%the type of the variational query and for an attribute \vAtt\ that a SQL query is not returning,
%it uses \ensuremath{\mathbf{NULL} \textit{\ } \mathbf{AS} \textit{\ } \vAtt} syntax),
%attaches the presence condition of variant SQL queries to them (by concating the
%feature expression with presence condition attribute in the returned attribute set),
%%, i.e., 
%%\ensuremath{\mathbf{presenceCond} \textit{\ }  
%and finally combines SQL queries by set operation union. 
The query is sent to the underlying
DBMS and the result is cleaned up by the variational table builder. Finally, it is 
returned to the user as a variational table. Note that cleaning up
the result is part of variational table builder tasks.
%% by attaching presence 
%%condition of attributes to them. 
%Here is the flow of how results are generated by 
%this approach:
That is:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\qGroup \vQ}}} [ \annot [\dimMeta] {\pQ} ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{generate}}}_{\mathrm{\textit{SQL}}}} [ \annot [\dimMeta] {\sqlQ} ]
\mathrel{\mathop{\rightarrow}^{\mathrm{union}}} {\VVal \sqlQ}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{query}}}} \textit{v-table}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{clean up}}}} \textit{v-table}
\]
%
\begin{example}
\label{eg:uav}
\wrrite{write the damn thing}
\end{example}
%
\end{enumerate}

We use the first two methods
%SQL generators 
to simulate existing approaches used to manage
variation currently. In particular, \nbf\ simulates how a naive
DBA would conduct such a task. \ubf\ simulates
how an expert DBA would conduct such a task. 
\uav\ attempts to reuse as much of the already existing results as possible. 
%
The generated SQL queries need to be independent from the 
underlying DBMS that stores the VDB. Hence, the SQL generator module
has a submodule that prints generated SQL queries for each DBMS engine. 


%add this somewhere: -> check that you have this in use cases
%We implemented these checks in our VDBMS tool and verified that both use cases
%described in this paper satisfy all of them. 
To ensure that these methods are implemented correctly we conducted two
sanity checks:
\begin{enumerate}
\item We check that the variation-preserving property at the semantics level
holds for all the methods. That is, we check that configuring the result gotten from
a method is the same as running the configured query over the corresponding 
configured database.
%
\item We check that the results from each two methods are equivalent based on
the equivalency relation over variational sets defined in \secref{vset} 
(specifically, in \secref{vset}).
\end{enumerate}

Our set of queries for both the email VDB and employee VDB passed these sanity checks.
