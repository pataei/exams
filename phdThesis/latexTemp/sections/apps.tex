\section{SQL Generators}
\label{sec:apps}


%\TODO{if parallel running of queries make a difference add it.}
%
Since VDBMS sits on top of a plain relational DBMS, in order to run
variational queries we must translate them into (sets of) plain relational queries,
that is, \emph{SQL generator} module's task.
These generators also inject the qualifiers of attributes in addition to 
adding the projection of presence condition attributes. We demonstrate this
in \exref{ubf} and \exref{uav}.
Then, VDBMS synthesizes the result into a variational table, that is, 
\emph{variational table builder} module's task.
%
Given an explicitly annotated well-typed variational query \vQ,
%constrained by the schema minimized variation, 
we provide three initial 
approaches to generate SQL query(ies) for \vQ:
\begin{enumerate}
%[wide, labelwidth=!, labelindent=0pt, topsep=1pt]
%\itemsep0em
\item
\emph{Naive Brute Force (\nbf)}:
Configures a variational query \vQ\ for all valid configurations, that is, 
\ensuremath{\forall \config \in \confSet}, translates them to RA queries,
and finally generates SQL queries with renaming all subqueries. The 
SQL queries are sent to underlying DBMS and the results are gathered and
cleaned up in variational table builder module. Here is the flow of how results are generated by 
this approach:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\eeSem \vQ}}} [ ( \config, \pQ ) ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{translate}}}_{\mathrm{\textit{to SQL}}}} [ ( \config, \sqlQ ) ]
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{queries}}}} \textit{v-tables}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{v-table}}}_{\mathrm{\textit{builder}}}} \textit{v-table}
\]
%
%\begin{example}
%\label{eg:nbf}
%\wrrite{write the damn thing}
%\end{example}
%
\item
\emph{Unique Brute Force (\ubf)}:
This approach is just like \nbf\ except that we only generate SQL 
queries for unique RA queries which are the result of configuring the variational query.
That is, it uses the unique variants function \ensuremath{\qGroup \vQ} introduced
in \secref{vraconf}.
%The trick is to attach the condition under which a 
%RA query is valid. This condition is a feature expression generated from
%the set of configurations that configured the variational query into the same RA query, that is,
%\ensuremath{
%\qGroup \vQ = \setDef {\annot \pQ \myOR \forall \config \in \confSet: \fSem \dimMeta = \t,
%\eeSem \vQ = \pQ}
%}. 
The implementation of this function is more efficient than its definition.
%\remember{
%In fact, it follows the function defined in \figref{} in \appref{}.
%}
That is:
%Groups variants of a variational query, translates them to RA queries,
%and generates SQK queries with renaming subqueries. Similar to 
%\ensuremath{(1)} results are gathered and cleaned up by variational table builder module.
%Here is the flow of how results are generated by 
%this approach:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\qGroup \vQ}}} [ \annot [\dimMeta] {\pQ} ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{translate}}}_{\mathrm{\textit{to SQL}}}} [ \annot [\dimMeta] {\sqlQ} ]
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{queries}}}} \textit{v-tables}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{v-table}}}_{\mathrm{\textit{builder}}}} \textit{v-table}
\]
%
\begin{example}
\label{eg:ubf}
Consider query $\vQ_1 = \pi_{\optAtt [\vFour \vee \vFive] [\empno], \name, \fname, \lname} (\empbio)$ given in \exref{vq-specific}. Its corresponding SQL queries generated by either \nbf\ or \ubf\ 
that will eventually be run on the
database and their corresponding feature expression indicating the valid group of configurations are
given below.
For configurations \setDef {} and \setDef {\vThree}
(indicated by the feature expression $(\neg \vThree \wedge \neg \vFour \wedge \neg \vFive) \vee 
(\vThree \wedge \neg \vFour \wedge \neg \vFive)$) we have the query:
%
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
SELECT NULL
\end{lstlisting}
%
For configuration \setDef {\vFour} (indicated by the feature
express $\neg \vThree \wedge \vFour \wedge \neg \vFive$) we have the query:
%
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
SELECT empno, 
        name,
        CONCAT( '(', t0.prescond, ')') AS prescond
FROM v_empbio AS t0
\end{lstlisting}
%
And finally, for configuration \setDef {\vFive} (indicated 
by the feature expression $\neg \vThree \wedge \neg \vFour \wedge \vFive$) we have the
query:
%
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
SELECT empno,
        firstname, 
        lastname,
        CONCAT( '(', t0.prescond, ')') AS prescond
FROM v_empbio AS t0
 \end{lstlisting}
%
Note that the only difference between \nbf\ and \ubf\ is that the former uses configurations
and assigns them to SQL queries and then gathers their tables into a variational tables 
whereas the latter uses the feature expressions indicating a group of configuration and
assigns them to  SQL queries and then gathers their tables into a variational tables. 
For example, \nbf\ uses the configurations given in this examples and runs the first SQL
query twice whereas \ubf\ uses the feature expressions and thus, runs each SQL only 
once. This does not have a big impact as long as the query is an empty query but it would
be less efficient otherwise.
\end{example}
%
\item
\emph{Union-All-Variants (\uav)}:
This approach takes the SQL queries generated by \ubf\ and 
unions them to just run one SQL query. In order to do so it 
forces all the SQL queries to return the same relation schema.
%return the same set of attributes.
Additionally, it applies the presence condition of a SQL query
to its tuples by concating it with the presence condition attribute
in the projected attribute set.
%Groups variants of a variational query, translates them to RA queries, 
%translates RA queries to SQL queries, 
%%generates one SQL query from all SQL queries by u
%unifies the set of
%attributes returned by SQL queries (by getting all returned attributes from
%the type of the variational query and for an attribute \vAtt\ that a SQL query is not returning,
%it uses \ensuremath{\mathbf{NULL} \textit{\ } \mathbf{AS} \textit{\ } \vAtt} syntax),
%attaches the presence condition of variant SQL queries to them (by concating the
%feature expression with presence condition attribute in the returned attribute set),
%%, i.e., 
%%\ensuremath{\mathbf{presenceCond} \textit{\ }  
%and finally combines SQL queries by set operation union. 
The query is sent to the underlying
DBMS and the result is cleaned up by the variational table builder. Finally, it is 
returned to the user as a variational table. Note that cleaning up
the result is part of variational table builder tasks.
%% by attaching presence 
%%condition of attributes to them. 
%Here is the flow of how results are generated by 
%this approach:
That is:
%
\[\vQ \mathrel{\mathop{\rightarrow}^{\mathrm{\qGroup \vQ}}} [ \annot [\dimMeta] {\pQ} ] 
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{generate}}}_{\mathrm{\textit{SQL}}}} [ \annot [\dimMeta] {\sqlQ} ]
\mathrel{\mathop{\rightarrow}^{\mathrm{union}}} {\VVal \sqlQ}
\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{run}}}_{\mathrm{\textit{query}}}} \textit{v-table}
%\mathrel{\mathop{\rightarrow}^{\mathrm{\textit{clean up}}}} \textit{v-table}
\]
%
\begin{example}
\label{eg:uav}
Consider query $\vQ_1 = \pi_{\optAtt [\vFour \vee \vFive] [\empno], \name, \fname, \lname} (\empbio)$ 
introduced in \exref{vq-specific}. The final SQL query generated by the \uav\ approach is:
 \begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
 (SELECT empno,
          firstname,
          lastname,
          NULL AS name,
          CONCAT( '(', t0.prescond, ')', ') AND ('
                 , '(NOT v3 AND v4) AND NOT v5'
                 , ')') AS prescond,
  FROM empbio AS t0) 
UNION ALL 
 (SELECT empno,
          NULL AS firstname,
          NULL AS lastname,
          name,
          CONCAT( '(', t1.prescond, ')', ') AND ('
                 , '(NOT v3 AND NOT v4) AND v5'
                 , ')') AS prescond
  FROM empbio AS t1)
 \end{lstlisting}
%
\end{example}
%
\item 
\emph{Injected Naive Brute Force (\nbfi)}: 
Alternatively, the feature expression associated with a configuration can be injected
inside the SQL query. Thus, simplifying the variational table builder to just fix the 
schema of the returned tables. \exref{ubfi} illustrates this approach. 
%
\item 
\emph{Injected Unique Brute Force (\ubfi)}:
Similarly, the injection of feature expressions into the SQL queries can be applied to
the \ubf\ approach. \exref{ubfi} illustrates this approach.
%
\begin{example}
\label{eg:ubfi}
Employing the \nbfi\ or \ubfi\ approaches to the query $\vQ_1$ results in the following SQL queries.
For configuration \setDef {\vFour} (indicated by the feature
express $\neg \vThree \wedge \vFour \wedge \neg \vFive$) we have the query:
%
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
SELECT empno, 
        name,
        CONCAT( '(', t0.prescond, ')', ') AND ('
               , '(NOT v3 AND v4) AND NOT v5'
               , ')') AS prescond,
FROM v_empbio AS t0
\end{lstlisting}
%
For configuration \setDef {\vFive} (indicated 
by the feature expression $\neg \vThree \wedge \neg \vFour \wedge \vFive$) we have the
query:
%
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,lineskip=0.5\baselineskip]
SELECT empno,
        firstname, 
        lastname,
        CONCAT( '(', t0.prescond, ')', ') AND ('
               , '(NOT v3 AND NOT v4) AND v5'
               , ')') AS prescond
FROM v_empbio AS t0
 \end{lstlisting}
%
\end{example}
\end{enumerate}

We use the first two methods
%SQL generators 
to simulate existing approaches used to manage
variation currently. In particular, \nbf\ simulates how a naive
DBA would conduct such a task. \ubf\ simulates
how an expert DBA would conduct such a task. 
\uav\ attempts to reuse as much of the already existing results as possible. 
%
The generated SQL queries need to be independent from the 
underlying DBMS that stores the VDB. Hence, the SQL generator module
has a submodule that prints generated SQL queries for each DBMS engine. 


%add this somewhere: -> check that you have this in use cases
%We implemented these checks in our VDBMS tool and verified that both use cases
%described in this paper satisfy all of them. 
To ensure that these methods are implemented correctly we conducted two
sanity checks:
\begin{enumerate}
\item We check that the variation-preserving property at the semantics level
holds for all the methods. That is, we check that configuring the result gotten from
a method is the same as running the configured query over the corresponding 
configured database.
%
\item We check that the results from each two methods are equivalent based on
the equivalency relation over variational sets defined in \secref{vset} 
(specifically, in \secref{vset}).
\end{enumerate}

Our set of queries for both the email VDB and employee VDB passed these sanity checks.
