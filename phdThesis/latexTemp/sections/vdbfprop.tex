\section{Properties of a Variational Database Framework}
\label{sec:vdbfprop}


In this section, we describe a set of basic properties that a well-formed VDB
should satisfy.
%
These checks ensure that presence conditions are consistent and satisfiable,
which ensures that each element is present in at least one variant.
%
In the following, $\sat\dimMeta$ denotes a satisfiability check
that returns \t\ if the feature expression \dimMeta\ is satisfiable and \f\
otherwise.


A well-formed v-schema should have the following properties:
%
\begin{enumerate}
%
\item There is at least one valid configuration of the VDB feature model $\getPC \vSch$:\\
%
\centerline{
$\sat {\getPC \vSch}$}
%
\item Every relation \vRel\ is present in at least one configuration of the
variational schema \vSch:\\
%
\centerline{
$\forall\vRel\in\vSch. \sat{\getPCfrom \vRel \vSch}$}
%
\item Every attribute \vAtt\ in every relation \vRel\ is present in at least one
configuration of the variational schema \vSch:\\
%
\centerline{
$\forall\vAtt\in\vRel, \forall\vRel\in\vSch.
\sat{\getPCfrom \vRel \vSch \wedge\getPCfrom \vAtt \vRel}$}
%
\item If $\vSch_\config$ denotes the expected plain relational schema for
configuration $c$ of the variational schema \vSch, then configuring the
variational schema with that configuration, written $\sem[\config]{\vSch}$,
actually yields that variant:\\
%
\centerline{
$\forall\config\in\confSet. \osSem {\vSch} = \vSch_\config$}
%
\end{enumerate}


\noindent
%
At the data level, a well-formed VDB should have these properties:
%
\begin{enumerate}
%
\item Every tuple \vTuple\ in relation \vRel\ is present in at least one variant:\\
%
\centerline{
$\forall\vTuple\in\vRel, \forall\vRel\in\vSch.
\sat{\getPCfrom\vRel \vSch\wedge\getPCfrom \vTuple \vRel}$ }
%
\item For every tuple \vTuple\ in relation \vRel, if an attribute \vAtt\ in \vRel\ is
not present in any variants of the tuple, then the value of that attribute in
the tuple, written $\mathit{value}_\vTuple(\vAtt)$, should be NULL:\\
%\centerline{
$\forall\vTuple\in\vRel, \forall\vAtt\in\vRel,\forall \vRel\in\vSch.
\neg\sat{\getPCfrom \vRel \vSch \wedge\getPCfrom \vAtt \vRel\wedge\getPCfrom \vTuple \vRel}
\Rightarrow \mathit{value}_\vTuple(\vAtt) = \nul$
%
\end{enumerate}


\noindent
%
%
 Since a single VDB can supply data for many different database variants at the
 same time, encoding variation explicitly in a database allows the developers
 to check for different properties over all database variants.
%
Thus, depending on the context of the VDB, more specialized properties can be checked.
For example, if temporal variability in a database is accumulated over
variants (i.e.\ old data is included in more recent variants in addition to
newly added data), it is desirable to ensure that older variants are subsets of
newer variants.
%
This property should hold for our employee dataset, introduced in 
\secref{emp-vdb}. To check this, 
assume that configurations \ensuremath{\config_1, \config_2, \cdots}
represent time-ordered configurations, then check
\ensuremath{
\forall \config_i, \config_j \in \confSet, i \le j, \odbSem [\config_i] {\vdbInst} \subseteq \odbSem [\config_j]{\vdbInst}
}, 
where \ensuremath{\odbSem[\config]{\vdbInst}} denotes configuring the VDB instance
\vdbInst\ for configuration \config, defined in \figref{vdb-conf}.
%\parisa{note to myself, impl todo: actually check this for employee db when you got the time!}

%v-table checks:
%- \ensuremath{\forall tuple \in relation \in schema : sat (fm \wedge pc_relation \wedge pc_tuple)}\\
%- \ensuremath{\forall attribute \in relation \in schema, \forall val : if unsat (fm \wedge pc_relation \wedge pc_attribute \wedge pc_tuple)} then value must be null\\


