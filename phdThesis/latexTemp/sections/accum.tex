\subsection{Accumulation of Relational Tables to a Variational Table}
\label{sec:accum}

\eric{pls read this entire section. thx!}
After connecting variational queries to relational queries, to define the 
semantics of VRA we need to connect
the results of multiple relational queries to the result of a single variational 
query. 
%
Since we have two approaches to connect a variational query to relational queries 
we define two \emph{accumulation} functions that generate a 
variational table from a set of relational tables. 
%
The first accumulation function $\mathit{accum} : \settype \fSet \totype \settype {\typepair \confSet \pTabSet} \totype \tabletype$ takes the feature space of a database and a set of relational
tables with their attached configurations and generates a variational table. \figref{accum1} 
defines this function in terms of some auxiliary functions. 
%
The $\mathit{mkTable}$ function takes a variational relation schema and a set of 
variational relation contents and generates a variational table that has the given schema
and the variational tuples in the input tables. 
%
The $\mathit{addPresCondToConfTables}$ function maps the $\mathit{addPresCondToConfContent}$
over a set of tables and their attached configuration and the  $\mathit{addPresCondToConfContent}$
function adds the \pcatt\ attribute to a relational table and its corresponding value which is 
a feature expression associated with the given configuration using the closed set of
features.
%
The $\mathit{fitConfTablesToVsch}$ maps the function $\mathit{fitTableToVsch}$ to tables of a set of 
relational tables and their attached configuration.
The $\mathit{fitTableToVsch}$ function adjusts a table, both its schema and content, 
to a variational relation schema.
%
The $\mathit{tablesToVsch}$ maps the function $\mathit{schToVsch}$ to a set of 
relational tables and their attached configuration. 
The $\mathit{schToVsch}$ generates a variational relation schema from a set of
plain relation schema and their attached configuration given the closed set of 
features of the database's feature space.%
\footnote{In implementation, for efficiency, we pass the type of the query from VRA's type system
as the variational relation schema that is generated by the $\mathit{tablesToVsch}$ function.}
%
Note that to generate a feature expression from a configuration it is essential to
pass the closed set of features.
%
\exref{acc-table-from-conf} illustrates the behavior of these auxiliary functions and the
table accumulation function over the relational tables in \tabref{vq-conf-res}.


\input{formulas/accum1}

\begin{example}
\label{eg:acc-table-from-conf}
Consider the query $\VVal {\vQ_1}$ written over the VDB with variational schema $\vSch_2$ and 
feature space $\features = \setDef {\vThree, \vFour, \vFive}$, all given in \exref{vq-specific}. 
%
All configured relational queries of $\VVal {\vQ_1}$ for VDB's valid configurations and their
corresponding results in form of a relational table are given
in \exref{vq-sem} and \tabref{vq-conf-res}, respectively. 
%
Now we show how the relational tables of the configured queries, shown in \tabref{vq-conf-res}, are accumulated 
to the variational table, shown in \tabref{vq1-res}, as the result of the variational query $\VVal \vQ_1$ by 
using the table accumulation function $\mathit{accum}$.
%
As the first step of accumulation, we generate the variational relation schema by
applying $\mathit{tablesToVsch}$ to tables in \tabref{vq-conf-res}. 
This results in the variational relation schema $\vRelSch_{\mathit{accum}}$
%
\begin{alignat*}{1}
\vRelSch_{\mathit{accum}} &= \mathit{result} (\annot [(\neg \vThree \wedge \vFour \wedge \neg \vFive)\vee(\neg \vThree \wedge \neg \vFour \wedge \vFive)] \empno, \annot [\neg \vThree \wedge \vFour \wedge \neg \vFive] \name,\\
&\hspace{30pt}\annot [\neg \vThree \wedge \neg \vFour \wedge \vFive] \fname, \annot [\neg \vThree \wedge \neg \vFour \wedge \vFive] \lname)^{\oneof {\vThree,\vFour,\vFive}}
\end{alignat*}
%
\noindent
Note that the presence conditions are generated based on the configurations attached to
the tables. For example, the presence condition $(\neg \vThree \wedge \vFour \wedge \neg \vFive)\vee(\neg \vThree \wedge \neg \vFour \wedge \vFive)$ associated with the attribute \empno\
is the disjunction of  two feature expressions $(\neg \vThree \wedge \vFour \wedge \neg \vFive)$
and $(\neg \vThree \wedge \neg \vFour \wedge \vFive)$ where they represent the configuration
\setDef \vFour\ (associated to \tabref{vq-conf2}) and \setDef \vFive\ (associated to \tabref{vq-conf3}),
respectively. That is, the configuration \setDef\ \vFour\ represents the variants that only enable the
feature \vFour\ from \vThree--\vFive, thus, its corresponding feature expression is $(\neg \vThree \wedge \vFour \wedge \neg \vFive)$. That is why we need to pass the closed set of features 
to the auxiliary functions (to generate feature expression corresponding to configurations).

%
In the next step, the tables in \tabref{vq-conf-res} are adjusted so that they all match a certain
relation schema. This is achieved by the $\mathit{fitConfTablesToVsch}$ which gets all the 
tables in \tabref{vq-conf-res} with their associated configurations and the variational relation
schema generated by passing them to the $\mathit{tablesToVsch}$. This is done by
mapping the  $\mathit{fitTableToVsch}$ to all the tables in 
\tabref{vq-conf-res} with their associated configurations. This function simply adds
 attributes of the variational relation schema to the table that do not exists in the table 
 and puts \nul\ as values (indicated by the white space) in the tuples for those attributes. 
%
\tabref{fitting1}--\tabref{fitting3} illustrate the application of 
$\mathit{fitTableToVsch}$ to \tabref{vq-conf1}--\tabref{vq-conf3} and variational relation 
schema $\vRelSch_{\mathit{accum}}$.
%
\input{tables/fitting1}
\input{tables/fitting2}
\input{tables/fitting3}
%
Then, the $\mathit{addPresCondToConfContent}$ 
function adds the presence condition attribute and its values 
to relation contents of \tabref{fitting1}--\tabref{fitting3}, resulting in \tabref{pcadded} which illustrates a set of 
relation contents that are separated by the red bold line. Note that since \tabref{fitting1}
does not have any tuples \tabref{pcadded} does not have any tuples associated with
the variant \setDef \vThree.
%
\input{tables/pcadded}
%
Finally, the $\mathit{mkTable}$ function takes the variational relation schema $\vRelSch_{\mathit{accum}}$
and \tabref{pcadded}. Note that the values in tuples of \tabref{pcadded} follow the order of the
attributes in the variational relation schema. This results in \tabref{mktab} which is equivalent to
the result of $\VVal \vQ_1$ given in \tabref{vq1-res}.
%
\input{tables/mktab}
\end{example}

The second accumulation function
 $\VVal {\mathit{accum}} :  \settype {\bm{(}\vartype \pTabSet\bm{)}} \totype \tabletype$ 
 takes a set of relational tables that are annotated with
a feature expression instead of their attached configuration. \figref{accum2} defines
this function and its auxiliary functions. The auxiliary functions are similar to the ones
defined in \figref{accum2} except that they do not need to generate a feature expression
from a configuration and a set of closed features.
%
%\exref{acc-table-from-group} illustrates the behavior of these auxiliary functions and the second accumulation
%function over the tables in \tabref{vq-conf-res}.

\input{formulas/accum2}

%\begin{example}
%\label{eg:acc-table-from-group}
%\wrrite{write this}
%\end{example}