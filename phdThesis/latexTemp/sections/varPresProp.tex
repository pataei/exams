\subsection{Type Safety}
\label{sec:var-pres}

%\arashComment{ The property of variation preservation is too short and it is not clear why it is important. I also did not find the proofs in Appendix D.}
%\resp{I established why such a property is important in the variational context where we are putting all variants together throughout the paper. here we just define the property and say that it holds at the type level. We also decided to just introduced this as a property for VLDB submission. We'll have the proofs and other properties in another paper.}
%\responded
To show that VRA is type safe we benefit from RA's type safety~\cite{RAtypeSys}
by defining the \emph{variation-preserving} property for VRA which connects VRA to RA.
%Variation-preserving property of VRA's type system and RA's type safety~\cite{RAtypeSys} 
%implies that VRA's type system is also type safe.
%Similar to other applications of variational research~\cite{CEW16ecoop,CEW14toplas},
%the type system must preserve
% the variation encoded in a variational query.
%
The 
\emph{variation-preserving property with respect to variational schema} states that
if a query \vQ\ has type \vType\ then 
configuring the type of a valid explicitly annotated query
is the same as the type of its configured
corresponding query. 
%
\thmref{var-pres} proves this property.

%, 
%i.e., no matter which path the constrained query takes in the diagram it will results
%to the same set of attributes.
%
% the code that produces the diagram
%\hspace{-2cm}
\begin{wrapfigure}{r}{0.24\textwidth}
\begin{center}
\begin{tikzcd}[column sep=2.3em]
  \constrain \vQ   \rar{\mathit{type}}  \dar[swap,dashed]{\eeSem . }
& {\annot \vType}  \dar[dashed]{\olSem . } \\
  \pQ \rar{\underline{type}}
& \pAttList
\end{tikzcd}
\end{center}
\end{wrapfigure}
%
\thmref{var-pres} is visualized in the diagram below, where 
the vertical arrows indicate corresponding configure functions,
\ensuremath{\mathit{type}} indicates VRA's type system, 
that is, \ensuremath{\mathit{type}(\vQ, \vSch) = \annot \vAttList} is 
\ensuremath{\envWithoutVctx \vQ {\envInContext [ \vctx] \vType}},
% of variational query \vQ\
%generated by VRA's type system and 
and
\ensuremath{\underline{\mathit{type}} (\pQ, \underline {\vSch})} indicates RA's type system
for the relational query \pQ\ over the relational database schema $\underline {\vSch}$,
that is, \ensuremath{\pEnv {\pQ} {\pAttList}}.
%Note that for simplicity, w
We assume that corresponding variation schema and schema is
passed to type systems.
% of relational query \pQ.
Simply put, 
the relational type of the configured variational query \vQ\ with configuration \config, 
that is, \ensuremath{\underline {\mathit{type}} (\eeSem {\vQ}, \osSem \vSch)},
must be the same as the configured variational type 
of the variational query \vQ\ with configuration \config, 
that is, \ensuremath{\olSem {\mathit{type} (\vQ, \vSch)}}.
\emph{Clearly the diagram commutes}: taking either path of 1) configuring \constrain \vQ\ first and 
then obtaining the relational type of it or 
2) obtaining the variational type of \constrain \vQ\ first and then configuring it results
in the same set of attributes. 
The variation-preserving property enforces the maintenance of variants that a tuple
belongs to through running a query at the schema level.%
%, partially satisfying second part of 
%\nTwo~
\footnote{
We define this property as a test at the semantics level and show that
%We have not proved this property at the semantics level, however, 
all our experimental
queries passed it.}.
%the test for variation-preserving property at the semantics level.}.
%configuring a variational query \vQ\ for configuration \config\ first and then 
%if we configure variational query \vQ\ for a given configuration \config\ its type (a set of attributes)
%must be the same as if we generate the variational attribute set for
%\vQ\ by VRA's type system and then configure it with \config,
%
%\appref{type-sys-prop-proof} sketches the proof of 
%VRA's type system being variation-preserving.
\exref{var-pres} illustrates why the query must be constrained by the variation schema
in the variation-preserving diagram.

\begin{theorem}
\label{thm:var-pres}
For all configurations \config, if a query \vQ\ has type \annot \vType\ 
then its configured query \ensuremath{\eeSem {\constrain \vQ}}
has type \ensuremath{\olSem {\annot \vType}}, i.e., \\
\centerline{
\ensuremath{
\forall \config \in \confSet. \envWithoutVctx { \vQ} {\annot \vType} \Rightarrow 
\pEnv [\osSem {\vSch}] {\eeSem {\constrain \vQ}} {\olSem {\annot \vType}}
}}.
\end{theorem}

\begin{proof}
By structural induction. We proved this theorem in the Coq proof assistant~\cite{Khan21}.
\end{proof}


\thmref{var-pres} implies that for all valid configurations of a VDB, any variational
query is correlated to a relational query and since RA is type safe its queries are
type safe. Thus, variational queries are type safe. 

\begin{example}
\label{eg:var-pres}
Consider the variational query 
\ensuremath{\vQ_5 = \vPrj [{\vAtt_1, \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] \vRel} 
given in \exref{conf-vq}. It is well-typed
and  it has the type
\ensuremath{\vAttList =
\setDef {\optAtt [\fOne] [\vAtt_1], 
\optAtt [\fOne \wedge \fTwo] [\vAtt_2], 
\optAtt [\fTwo] [\vAtt_3]}
}.
Configuring \vAttList\ for the variant that both \fOne\ and \fTwo\ are disabled
results is an empty attribute set. However, the type of its configured query
for this variant, i.e., \ensuremath{\eeSem [\setDef \ ] {\vQ_5} =  \pi_{\pAtt_1} \pRel}, is the 
attribute set \ensuremath{\setDef {\pAtt_1}}. This violates the
variation-preserving property. A similar problem happens for the variant of
\setDef {\fTwo}, i.e., \ensuremath{
\underline{\mathit{type}} \left( \eeSem [\setDef \fTwo] {\vQ_5} \right) = 
\underline{\mathit{type}} \left( \pi_{\pAtt_1, \pAtt_3} \pRel \right) = 
\setDef{\pAtt_1, \pAtt_3} \not = \setDef{\pAtt_3} 
= \olSem [\setDef \fTwo] {\vAttList}
= \olSem [\setDef \fTwo] {\mathit{type} \left( \vQ_5 \right)}
}. However, the variation-preserving property holds for the 
constrained query by variation schema, i.e., 
\ensuremath{
\constrain [\vSch_3] {\vQ_5} = 
\vPrj [{\optAtt [\fOne] [\vAtt_1], \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] \vRel
}.
Thus, the input query to the configuration function \eeSem . \emph{must} be explicitly
annotated by the underlying variation schema for the configured query to match the underlying 
configured schema.
%We can restrict VRA's type system to enforce users to incorporate the
%variation schema into their queries, e.g., \ensuremath{\vQ_5} becomes
%\ensuremath{\VVal \vQ_5 = 
%\vPrj [{\optAtt [\fOne] [\vAtt_1], 
%\optAtt [\fOne \wedge \fTwo] [\vAtt_2], 
%\optAtt [\fTwo] [\vAtt_3]}] \vRel
%}. However, one of the purposes of our type system is to relieve the users 
%from having to encode the VDB's variability into their queries.
%% this burdens the user to know the exact variation encoded in
%%the database in addition to the original variation they want to encode in their query.
%To avoid this violation without requiring users to repeat VDB's variability in their queries,
%after type checking a query we push the variation schema onto the variational query,
%e.g., doing so for \ensuremath{\vQ_5} results in \ensuremath{\VVal \vQ_5}.
\end{example}

