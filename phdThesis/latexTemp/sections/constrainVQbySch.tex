\section{Explicitly Annotating Queries}
\label{sec:constrain}

%\point{type system allows the ql to be flexible and usable.}
%The type system is designed s.t. it relieves the user from necessarily incorporating
%the v-schema variability into their queries as long as the variational queries variability
%does not violate the v-schema, 
Variational queries do not need to repeat information that can be inferred from the variational schema
or the type of a query.
%
For example, the query \ensuremath{\vQ_1} shown in \exref{vq-specific} 
does not contradict the schema and
thus is type correct. However,
 it does not include the presence conditions of attributes and the relation encoded in
the schema while \ensuremath{\vQ_6} repeats this information:\\
%
\centerline{
\ensuremath{
\vQ_6 =
\pi_{\optAtt [(\vFour \vee \vFive) \wedge \neg \vThree] [\empno], \optAtt [\neg \vThree \wedge \vFour \wedge \neg \vFive] [\name], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\fname], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\lname]  } \left(\chc [\dimMeta_2] {\empbio, \empRel} \right)}}.%
%
\footnote{
The query $\vQ_6$ is the simplified version of
\[\constrain [\vSch_2] {\vQ_1} = 
\pi_{\optAtt [(\vFour \vee \vFive) \wedge \neg \vThree] [\empno], \optAtt [\neg \vThree \wedge \vFour \wedge \neg \vFive] [\name], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\fname], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\lname]  } \left(\constrain [\vSch_2] {\empbio}\right)\]
where $\constrain [\vSch_2] {\empbio} = \chc [\dimMeta_2] {\pi_{\empno, \annot [\vFour] \name, \annot [\vFive] \fname, \annot [\vFive] \lname} (\empbio),\empRel} $.
}

%\pi_{\optAtt [(\vFour \vee \vFive) \wedge \fModel_2] [\empno], \optAtt [\vFour \wedge \fModel_2] [\name], \optAtt [\vFive \wedge \fModel_2] [\fname], \optAtt [\vFive \wedge \fModel_2] [\lname]  } \empbio}}.
%

%\NOTE{
%This is the unsimplified version:
%\begin{align*}
%\VVal {\vQ_5} &= 
%\pi_{\optAtt [\vFour \vee \vFive] [\empno], \optAtt [\vFour] [\name], \optAtt [\vFive] [\fname], \optAtt [\vFive] [\lname]  } \\
%&(\chc [ \fModel_2 ] {\pi_{\empno, \sex, \birthdate, \optAtt [\vFour ] [\name], \optAtt [\vFive] [\fname], \optAtt [\vFive] [\lname]} \empbio, \empRel  })
%\end{align*}
%}
Similarly, the projection in the query 
\ensuremath{\vQ_7 = \pi_{\name, \fname} (\mathit{subq}_7)}
where 
\ensuremath{
\mathit{subq}_7 = \chc [ \vFour] {\pi_\name (\vQ_6), \pi_\fname (\vQ_6)}
}
is written over 
\ensuremath{\vSch_2} and it 
%\centerline{
%\ensuremath{
%\vQ_6 =
%\pi_{\name, \fname} \mathit{subq}_6
%} 
%}}
does not repeat the presence conditions of attributes from its \ensuremath{\mathit{subq}_7}'s type.
The query
%\centerline{
\ensuremath{
\vQ_8 =
\pi_{\optAtt [\vFour ] [\name],\optAtt [\neg \vFour] [\fname]} (\mathit{subq}_7)
%\chc [ \vFour] {\pi_\name \vQ_5, \pi_\fname \vQ_5}
}
%}
makes the annotations of projected attributes \emph{explicit} with respect to both 
the variational schema \ensuremath{\vSch_2} and its subquery's type.
%\TODO {give an example, schema: R(A,B), query: $\pi_{A,B} (F<\pi_A R, \pi_B R>)$
%becomes $\pi_{A^F, B^{\neg F}} ...$}
%The variation encoded in variational queries can
%be more restrictive or more loose than v-schema variation without violating them.
Although relieving the user from explicitly repeating variation makes VRA easier to use, 
queries still have to state variation explicitly to avoid losing information when 
decoupled from the schema.
%We do this by defining a function, 
%\ensuremath {\constrain \vQ}, with type \ensuremath{ \qSet \to \vSchSet \to \qSet
%},
%that \emph{explicitly annotates a query \vQ\ given the underlying schema \vSch}.
We do this by defining the function 
\ensuremath {\constrain \vQ : \qSet \totype \vSchSet \totype \qSet
},
that \emph{explicitly annotates a query \vQ\ with the  schema \vSch}.
%Note that \ensuremath {\constrain \vQ} needs to take the underlying schema as
%an input since it is using the type system (which relies on the schema) as a helper function.
The explicitly annotating query function, 
formally defined in \figref{constrain}, 
conjoins attributes and relations
presence conditions with the corresponding annotations in the query 
and wraps subqueries in a choice when needed. 
Note that, $\vQ_8$ and $\vQ_6$ are the result of $\constrain [\vSch_2] {\vQ_7}$
and $\constrain [\vSch_2] {\vQ_1}$, respectively, after simplification~\footnote{More specifically,
they are simpilified using rules defined in \figref{var-min}}.
%Queries $\vQ_7$ and $\vQ_5$ are examples of applying the 
%explicitly annotation function to queries $\vQ_6$ and $\vQ_1$, respectively,
%after simplifying them.
%\exref{constrain} illustrates how the constrain function transforms queries
%and allows users to be more flexible with their queries. 

\input{formulas/constrainVQbySch}

\begin{theorem}
\label{thm:expl-same-type}
If the query \vQ\ has the type \annot \vType\ then its explicitly annotated counterpart has an equivalent type, that is: \\
%
\centerline{
\ensuremath{%\raggedleft
\envWithoutVctx {\vQ} {\annot \vType} \Rightarrow \envWithoutVctx {\constrain \vQ} {\annot [\VVal \dimMeta] {\VVal \vType}} \textit{ and } \annot \vType \equiv \annot [\VVal \dimMeta] {\VVal \vType}
}}
%
\end{theorem}

\begin{proof}
By structural induction. We encoded and proved this theorem in the Coq proof assistant~\cite{Khan21}.
\end{proof}

This theorem shows that the type system applies the schema to the type of a query although it does not apply it to the query. 
The \emph{type equivalence} is variational set equivalence, defined 
in \figref{vset}, for normalized variational sets of attributes.
%\footnote{We proved this theorem in the Coq proof assistant. The encoding of the theorem and the proof can be found in second author's MS thesis~\cite{FaribaThesis}.}.

%We encode and prove \thmref{expl-same-type} in the Coq proof assistant~\cite{Khan21}.
We illustrate the application of \thmref{expl-same-type} to queries
\ensuremath{\vQ_1} and \ensuremath{\vQ_6}.
%
\exref{type} explained how \ensuremath{\vQ_1}'s type is generated step-by-step.
The variation context and underlying schema are
the same and the subquery \empbio\ has the same type. 
The projected attribute set annotated with the variation context is:\\
\ensuremath{
\vAttList_2 =  \{\annot [(\vFour \vee \vFive) \wedge \neg \vThree] \empno, 
%\ensuremath{ 
\optAtt [\neg \vThree \wedge \vFour \wedge \neg \vFive] [\name], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\fname], \optAtt [\neg \vThree \wedge \neg \vFour \wedge \vFive] [\lname]\}^{\dimMeta_2}}, which is clearly subsumed by \ensuremath{\vAttList_\empbio}, thus, 
%the type of \empbio, \vAttList, and
its intersection with \ensuremath{\vAttList_\empbio} annotated
with the presence condition of \ensuremath{\vAttList_\empbio} is itself,
hence, \ensuremath{\vAttList_{\vQ_1} \equiv \vAttList_{\vQ_6}}.
%which makes it obvious that \ensuremath{\vAttList_{\vQ_1} \equiv \vAttList_{\vQ_6}}.
%\end{example}


%
Explicitly annotating variational queries not only relieves the user from repeating the
database's variation in their queries but it is also necessary for the functions that 
take a query without taking the schema, such as the query configuration function 
which is explained in \secref{vraconf}.
This is contra to other functions that have to take both the query and the 
schema, such as the type system. 
We explain this in more details in \secref{vraconf}.
%\exref{exp-annot-nec} illustrates why a query passed to the configuration function 
%must be explicitly annotated.
%
%\begin{example}
%\label{eg:exp-annot-nec}
%Consider the variational query $\vQ_5= \vPrj [{\vAtt_1, \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] (\vRel)$ given in
%\exref{conf-vq}. This query is not explicitly annotated since attribute $\vAtt_1$ does not
%carry its variational encoding from the database, that is, it does not have the presence
%condition $\A$. Explicitly annotating this query gives us query $\VVal {\vQ_5} =  \vPrj [{\optAtt [\A][\vAtt_1], \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] (\vRel)$.
%Configuring $\VVal {\vQ_5}$ results in the same query as configuring $\vQ_5$ except for 
%configuration \setDef {\ }, that is, $\eeSem [\setDef \ ] {\VVal {\vQ_5}} = \pi_{\setDef {\ }} \pRel = \empRel$. The reason why $\eeSem [\setDef \ ] {\vQ_5} $ is incorrect is that $\vQ_5$ is missing
%the variation attached to attribute $\vAtt_1$ and the configuration function does not consider
%the schema of a database while configuring variational queries written over that database. 
%\end{example}
