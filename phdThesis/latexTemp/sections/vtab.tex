\section{Variational Table}
\label{sec:vtab}

\TODO{change vdb conf to vtab.}
\rewrite{read and revise}
\fromppr{vldb}
\TODO{remember to use definitions of config elem and vset}
%\input{formulas/vtabConf}

Variation also exists in database content. To account 
for content variability, we tag tuples with 
presence conditions. 
%e.g., the tuple $(1,2)^{\A}$ only exists
%when \A\  is enabled. 
%
Thus, a \emph{variational tuple} (\emph{v-tuple}) is an annotated tuple,
$\vTuple\in\vRelCont \eqq \annot[\dimMeta_\vTuple]{(\vi v \numAtts)}$. A
v-tuple corresponds to a v-relation,
$\vRel\annot[\dimMeta_\vRel]{(\vi \vAtt \numAtts)}$,
where each element $v_i$ is a value corresponding to attribute $\vAtt_i$
(recall that attributes in a v-relation are ordered).
%
For example, $\annot[\tFive]{(38, PL, 678)}$ is a v-tuple that belongs to the
\ecourse\ relation from \exref{vsch} and is only present when \tFive\ is
enabled. 
%
The content of a v-relation
%  \emph{variational relation content} 
is a set of v-tuples,
$\vRelCont \in \vRelContSet \eqq \setDef {\vi \vTuple \numTuples}$
and 
%
a \emph{variational table} (\emph{v-table}) is the pair of its relation
schema and content, $\vTab = (\vRelSch, \vRelCont)$.
%
A \emph{variational database instance}
%of VDB \vDB\ with v-schema \vSch, 
is a set of v-tables,
$\synDef \vdbInst  \vdbInstSet \eqq \annot [\fModel] {\setDef {\vi \vTab \numRels} }$.
%
A VDB instance is \emph{well-formed} if its encoded variation at
the schema and content level are consistent and satisfiable~\cite{ALW21vamos}.
% We define properties that must hold for a VDB to be well-formed can be 
% found in~\cite{ALW21vamos}.


\NOTE{The explanation in the following two paragraphs is really hard to follow.
Some ideas for improvement: (1) State the requirement that you're talking about
first, then explain how VDB satisfies it; currently the requirement comes at
the end, so for 1--3 sentences the reader is wondering why you're re-hashing
this aspect of VDB. (2) The reader has forgotten by now what the requirements
are, so a brief (few words) description is needed for each requirement as you
discuss it. (3) It would help to follow the same order of requirements as
\secref{mot} as closely as possible. 

\medskip
I recommend structuring this discussion more rigidly as, ``This encoding
satisfies \nZero, which is about foo, by doing bar. It satisfies \nOne, which
is about blah, by doing baz.'' Obviously there's plenty of room for making it
read more nicely than that, but the lack of structure is making it hard to
understand as-is.}


This encoding of variational databases satisfies the requirements for a
variational database described in \secref{mot}. Similar to a v-schema, a user
can configure a v-table or a VDB for a specific variant, formally defined in
\figref{vdb-conf} in \appref{vdb-conf}. This allows users to deploy a VDB for a
specific configuration and generate the corresponding VDB variant, satisfying
database part of \nThree\ need.
%
Additionally, 
our VDB framework puts all variants of a database into
one VDB (satisfying \nZero) 
and it keep tracks of which variant a tuple belongs to by 
annotating them with presence conditions. 
For example, consider tuples
\ensuremath{\annot [\tFive] {(38, PL, 678)}}
and 
\ensuremath{\annot [\tFour] {(23, DB, \nul)}}
that belong to the \ecourse\ table. 
The presence conditions \tFive\ and \tFour\ state that tuples belong to temporal
variants four and five of this VDB, respectively.
Hence, this framework tracks which variants a tuple belongs to 
(first part of \nTwo).


%As shown, o
Our VDB framework encodes variation in databases 
at two levels: schema and content.
% We do not extend variation to 
%the constraint level and only focus on variation at the schema 
%and content levels. 
In a database that is a variational artifact as defined in \secref{req},
while content-level variation can stand on its own, such as
frameworks used for database versioning and 
experimental databases~\cite{dbVersioning},
the schema level cannot, e.g., 
\ensuremath{
\ecourse \left(\cno, \cname, \optAtt [\tFive] [\deptno] \right)^{\edu \wedge \left(\tFour \vee \tFive\right)}
} encodes variation at the schema level for relation \ecourse.
Dropping the presence conditions of tuples leads to ambiguity, i.e.,
it is unclear which variant each of the tuples
\ensuremath{(38, PL, 678)}
and 
\ensuremath{(23, DB, \nul)} belongs to. We can only guess that
they belong to variants where \tFour\ or \tFive\ are enabled, but, 
we do not know for sure which one. Thus, it violates the \nTwo\ 
requirement of a variational database framework.
%where it is unclear which variant each tuple belongs to
%and there is no way to recover such information.
%Note that 
%the VDB framework encodes both schema- and content-level
%variation. A simpler framework could be used to encode 
%only content-level variation (where tables consist of v-tuples but
%have plain relational schema), similar to frameworks used for 
%database versioning and experimental databases~\cite{dbVersioning}.
%However, schema-level variation cannot be encoded without 
%accounting for content-level variation in a framework where
%variants coexist in parallel and they are all put into one database,
%e.g., while 
%\ensuremath{
%\ecourse \left(\cno, \cname, \optAtt [\tFive] [\deptno] \right)^{\edu \wedge \left(\tFour \vee \tFive\right)}
%} encodes variation at the schema-level for relation \ecourse,
%dropping presence conditions of tuples results in tuples
%\ensuremath{(38, PL, 678)}
%and 
%\ensuremath{(23, DB, \nul)}
%where it is unclear which variant each tuple belongs to
%and there is no way to recover such information.


Note that we limit the granularity of variation in content to tuples, that is,
the individual values within a tuple are not variational.
%
%Note that the value $v_i$ is present iff 
%$\sat {\dimMeta_\vTuple \wedge \dimMeta_\vRel \wedge \dimMeta_\vAtt \wedge \fModel}$,
%where, 
%$\dimMeta_\vAtt = \getPC {\getAtt i}$ and
%%,
%%$\dimMeta_\vTuple = \getPC \vTuple$,
%%\dimMeta = \getPC \vRel,
%%and 
%%\fModel\ is the feature model.
%%
%for simplicity, 
%%Also, note that to avoid overcrowding the database with variation and feature 
%%expressions
%we only annotate tuples and not cells. 
This design decision causes some redundancy.
For example, the two tuples
\ensuremath{\annot [\tFive] {(38, PL, 678)}} and 
\ensuremath{\annot [\neg \tFive] {(38, PL, \nul)}}
%\ensuremath{\annot [\fOne] {(1,2)}} and \ensuremath{\annot [\neg\fOne] {(1,3)}}
cannot be represented as a single tuple
% \ensuremath{(1, \chc [\fOne] {2,3})} 
with variation in the third element. However, this design decision
does not prevent us from distinguishing between a \nul\ value
that represents a missing value and a \nul\ value that represents
a cell that is not present. This distinction can be made by checking
the satisfiability of 
the presence condition of the value $v_i$ in tuple \vTuple\ of relation \vRel\ in schema \vSch:
If $\sat{\getPCfrom {v_i} \vTuple}$ then the \nul\ indicates a missing value
and otherwise it indicates a non-present cell, where 
\ensuremath{\getPCfrom {v_i} \vTuple = \dimMeta_\vTuple \wedge \getPCfrom \vRel \vSch
\wedge \getPCfrom {\getAtt i} \vRel}.
% \dimMeta_\vRel \wedge \dimMeta_\vAtt \wedge \fModel
%\revised{
%where \ensuremath{\chc [\fOne] {2,3}} is a \emph{choice} of values $2$ and $3$
%and it states that if \A\ is enabled the cell holds the value $2$ and otherwise it 
%holds the value $3$. }
%

%\input{formulas/vdbConf}
