\section{Variational Table}
\label{sec:vtab}


Thus far, 
we illustrated how variation can be incorporated into the schema of a database.
However, it does not suffice to only have variation at the schema level. Consider that the 
variants of the relation \empbio\ shown in \tabref{empbio-sch}. \tabref{empbio-tab}
include some of the tuples of these relation variants in addition to their schemas. 
To incorporate variation in the content of a variational relation we
extend each relation with a new attribute \pcatt\ that stores 
the presence condition of tuples, as shown in
\tabref{empbio-vtab}. Thus,
the value of this attribute for a tuple determines the set of variants that the tuple
belongs to. For example, the first tuple in the \tabref{empbio-vtab} is present for
all database variants that enable the feature \vThree. 
\input{tables/vtab}

%As shown thus far through an example, variation also exists in database content. 
%We embark on the formal definition of a variational table. 
To account 
for content variability in the formal definition we tag tuples with 
presence conditions. 
%e.g., the tuple $(1,2)^{\A}$ only exists
%when \A\  is enabled. 
%
Thus, a \emph{variational tuple} (\emph{v-tuple}) is an annotated tuple,
$\vTuple\in\vRelCont \eqq \annot[\dimMeta]{(\vi v \numAtts)}$. A
variational tuple corresponds to a variational relation,
$\vRel\annot[\dimMeta_\vRel]{(\vi \vAtt \numAtts)}$,
where each element $v_i$ is a value corresponding to attribute $\vAtt_i$
(recall that attributes in a variational relation are ordered).
%
For example, $\annot[\tFive]{(38, PL, 678)}$ is a variational tuple that belongs to the
\ecourse\ relation from \exref{vsch} and is only present when \tFive\ is
enabled. 
%
The content of a variational relation
%  \emph{variational relation content} 
is a set of variational tuples,
$\vRelCont \in \vRelContSet \eqq \setDef {\vi \vTuple \numTuples}$
and 
%
a \emph{variational table} (\emph{v-table}) is the pair of its relation
schema and content, $\vTab = (\vRelSch, \vRelCont)$.
%
A \emph{variational database instance}
%of VDB \vDB\ with variational schema \vSch, 
is a set of variational tables,
$\synDef \vdbInst  \vdbInstSet \eqq \annot [\dimMeta] {\setDef {\vi \vTab \numRels} }$.
%
\figref{vdb-conf} provides the formal definition of a VDB and its type synonyms.
A VDB instance is \emph{well-formed} if its encoded variation at
the schema and content level are consistent and satisfiable~\cite{ALW21vamos}.
\secref{vdbfprop} expands on this. 
% We define properties that must hold for a VDB to be well-formed can be 
% found in~\cite{ALW21vamos}.

\input{formulas/vtabConf}

%\NOTE{The explanation in the following two paragraphs is really hard to follow.
%Some ideas for improvement: (1) State the requirement that you're talking about
%first, then explain how VDB satisfies it; currently the requirement comes at
%the end, so for 1--3 sentences the reader is wondering why you're re-hashing
%this aspect of VDB. (2) The reader has forgotten by now what the requirements
%are, so a brief (few words) description is needed for each requirement as you
%discuss it. (3) It would help to follow the same order of requirements as
%\secref{mot} as closely as possible. 

%\medskip
%I recommend structuring this discussion more rigidly as, ``This encoding
%satisfies \nZero, which is about foo, by doing bar. It satisfies \nOne, which
%is about blah, by doing baz.'' Obviously there's plenty of room for making it
%read more nicely than that, but the lack of structure is making it hard to
%understand as-is.}


%This encoding of variational databases satisfies the requirements for a
%variational database described in \secref{mot}. 
Similar to a variational schema, a user
can configure a variational table or a VDB for a specific variant, formally defined in
\figref{vdb-conf}. This allows users to deploy a VDB for a
specific configuration and generate the corresponding VDB variant.
%, satisfying
%database part of \nThree\ need.
For example, configuring the variational table \empbio, shown in \tabref{empbio-vtab},
for configuration \setDef{\vThree, \edu, \tOne} results in the relational table \empbio\
in \tabref{empbio-tab-v3}, assuming the VDB has the variational schema $\vSch_\mot$
given in \exref{vsch-mot}.
%
Additionally, 
our VDB framework puts all variants of a database into
one VDB 
%(satisfying \nZero) 
and it keep tracks of which variant a tuple belongs to by 
annotating them with presence conditions. 
For example, consider tuples
\ensuremath{\annot [\tFive] {(38, PL, 678)}}
and 
\ensuremath{\annot [\tFour] {(23, DB, \nul)}}
that belong to the \ecourse\ table. 
The presence conditions \tFive\ and \tFour\ state that tuples belong to temporal
variants four and five of this VDB, respectively.
Hence, this framework tracks which variants a tuple belongs to.
%(first part of \nTwo).


%As shown, o
Our VDB framework encodes variation in databases 
at two levels: schema and content.
% We do not extend variation to 
%the constraint level and only focus on variation at the schema 
%and content levels. 
In a variational database,
% that is a variational artifact as defined in \secref{req},
while content-level variation can stand on its own, such as
frameworks used for database versioning and 
experimental databases~\cite{dbVersioning},
the schema level cannot. For example,
\ensuremath{
\ecourse \left(\cno, \cname, \optAtt [\tFive] [\deptno] \right)^{\edu \wedge \left(\tFour \vee \tFive\right)}
} encodes variation at the schema level for relation \ecourse.
Dropping the presence conditions of tuples leads to ambiguity, i.e.,
it is unclear which variant each of the tuples
\ensuremath{(38, PL, 678)}
and 
\ensuremath{(23, DB, \nul)} belongs to. We can only guess that
they belong to variants where \tFour\ or \tFive\ are enabled, but, 
we do not know for sure which one. 
%Thus, it violates the \nTwo\ 
%requirement of a variational database framework.
%where it is unclear which variant each tuple belongs to
%and there is no way to recover such information.
%Note that 
%the VDB framework encodes both schema- and content-level
%variation. A simpler framework could be used to encode 
%only content-level variation (where tables consist of variational tuples but
%have plain relational schema), similar to frameworks used for 
%database versioning and experimental databases~\cite{dbVersioning}.
%However, schema-level variation cannot be encoded without 
%accounting for content-level variation in a framework where
%variants coexist in parallel and they are all put into one database,
%e.g., while 
%\ensuremath{
%\ecourse \left(\cno, \cname, \optAtt [\tFive] [\deptno] \right)^{\edu \wedge \left(\tFour \vee \tFive\right)}
%} encodes variation at the schema-level for relation \ecourse,
%dropping presence conditions of tuples results in tuples
%\ensuremath{(38, PL, 678)}
%and 
%\ensuremath{(23, DB, \nul)}
%where it is unclear which variant each tuple belongs to
%and there is no way to recover such information.


Note that we limit the granularity of variation in content to tuples, that is,
the individual values within a tuple are not variational.
%
%Note that the value $v_i$ is present iff 
%$\sat {\dimMeta_\vTuple \wedge \dimMeta_\vRel \wedge \dimMeta_\vAtt \wedge \fModel}$,
%where, 
%$\dimMeta_\vAtt = \getPC {\getAtt i}$ and
%%,
%%$\dimMeta_\vTuple = \getPC \vTuple$,
%%\dimMeta = \getPC \vRel,
%%and 
%%\fModel\ is the feature model.
%%
%for simplicity, 
%%Also, note that to avoid overcrowding the database with variation and feature 
%%expressions
%we only annotate tuples and not cells. 
This design decision causes some redundancy.
For example, the two tuples
\ensuremath{\annot [\tFive] {(38, PL, 678)}} and 
\ensuremath{\annot [\neg \tFive] {(38, PL, \nul)}}
%\ensuremath{\annot [\fOne] {(1,2)}} and \ensuremath{\annot [\neg\fOne] {(1,3)}}
cannot be represented as a single tuple
% \ensuremath{(1, \chc [\fOne] {2,3})} 
with variation in the third element. However, this design decision
does not prevent us from distinguishing between a \nul\ value
that represents a missing value and a \nul\ value that represents
a cell that is not present. 
This distinction can be made by checking
the satisfiability of 
the presence condition of the value $v_i$ in tuple \vTuple\ with of relation \vRel\ in schema \vSch:
If $\sat{\getPCfrom {\getAtt i} \vSch \wedge \getPCfrom \vTuple \vRel \wedge \getPCfrom \vRel \vSch}$ 
then the \nul\ indicates a missing value
and otherwise it indicates a non-present cell.
%, where 
%\ensuremath{\getPCfrom {v_i} \vTuple = \dimMeta_\vTuple \wedge \getPCfrom \vRel \vSch
%\wedge \getPCfrom {\getAtt i} \vRel}.
% \dimMeta_\vRel \wedge \dimMeta_\vAtt \wedge \fModel
%\revised{
%where \ensuremath{\chc [\fOne] {2,3}} is a \emph{choice} of values $2$ and $3$
%and it states that if \A\ is enabled the cell holds the value $2$ and otherwise it 
%holds the value $3$. }
%


