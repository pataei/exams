\section{VRA Type System}
\label{sec:type-sys}

%\input{formulas/vRelAlgTypingRules}
%\input{formulas/vRelAlgTypingRulesHorz}
%\input{formulas/vRelAlgTypingRulesExplicitAnnotation}

%\input{formulas/vRelAlgTypingRulesExplicitAnnotation}


%\point{aspects we need to type check variationalqueries.}
In this section, we introduce a static type system for VRA. The type system
ensures that queries are consistent with the underlying variationalschema. That is, that
all referenced relations and attributes are present in the variation contexts
in which they are used.
%
For example, consider the VDB from \exref{conf-vq} that contains only the
relation $\vRel(\optAtt[\fOne][\vAtt_1],\vAtt_2,\vAtt_3)^{\fOne\vee\fTwo}$. The
query $\vPrj[\vAtt_4]{\vRel}$ is ill-typed since $\vAtt_4$ is not present in
$\vRel$. Similarly, the queries $\vPrj[{\optAtt[\neg\fOne][\vAtt_1]}]{\vRel}$
and $\chc[\fOne]{\vPrj[\vAtt_2]{\vRel},\vPrj[\vAtt_1]{\vRel}}$ are both
ill-typed since $\vAtt_1$ is not present in \vRel\ when \fOne\ is disabled.


The type of a VRA query is a variational relation schema
$\mathit{result}\annot{(\vAttList)}$. However, since the
relation name is the same for all queries, we shorten this to
$\annot{\vAttList}$, that is, an annotated variational set of attributes.
%
The annotation $e$ corresponds to the presence condition of the 
returned table.
%
The presence conditions of attributes within $A$ may differ from the
corresponding presence conditions in the original variational schema due to variation
constraints imposed by the query.
%
For example, continuing with relation
$\vRelSch=\vRel(\optAtt[\fOne][\vAtt_1],\vAtt_2,\vAtt_3)^{\fOne\vee\fTwo}$, the
query $\vPrj[{\optAtt[\fOne][\vAtt_2]}]{\vRel}$ has type
$\{\annot[\fOne]{\vAtt_2}\}^{\fOne\vee\fTwo}$. 
%
In the original schema, $\vAtt_2$ is present when $\A\vee\B$, while in the
query it is present only when $\A$ is enabled.

\input{formulas/vRelAlgTypingRules}

\figref{vq-stat-sem} defines a typing relation that relates VRA queries to
their types.
%
The judgment form \env{\vQ}{\envInContext[\VVal{\vctx}]{\vType}} states that
in variation context \vctx\ within variational schema \vSch, variational query \vQ\ has type
\envInContext[\VVal{\vctx}]{\vType}. 
%
If a query does not have a type, it is \emph{ill-typed}.
%
A \emph{variation context} is a feature expression that tracks which variants
the current subquery is present in.
%
We sometimes use the judgment form \envWithoutVctx{\vQ}{\envInContext[\VVal{\vctx}]{\vType}}
when the variation context is the unextended feature model, that is,
\env[\getPC{\vSch}]{\vQ}{\envInContext[\VVal{\vctx}]{\vType}}.
%
We assume that the variational set of attributes $A$ is normalized to remove elements
with unsatisfiable presence conditions, but this normalization is only shown
explicitly in the rules where strictly necessary.


The rule \relationE\ looks up relation \vRel\ in the variational schema \vSch\ and
returns its variational set of attributes $A$. The presence condition of $A$ is the
conjunction of the relation's presence condition in the variational schema, $e'$, the
current variation context, $e$, and the feature model, $\getPC{\vSch}$. In this
way, the type is constrained to reflect both the constraints present in the
variational schema and the context of the relation reference in the query.
%
The last premise ensures that the relation exists in at least one variant by
checking that the type's presence condition is satisfiable. This means that
referencing a relation in a context where it is never present is a type error.
%The rule \relationE\ looks up the relation \vRel\ in the 
%variational schema \vSch\ and returns its variational set of attributes \vAttList\ annotated
%with the variation context and its presence condition $\vctx \wedge \VVal \dimMeta \wedge \getPC \vSch$. 
%%
%That is, it states that, in variation context \vctx\ with
%underlying variational schema \vSch, assuming that
%1) \vSch\ contains
%the relation \vRel\ with presence condition $\VVal \dimMeta$
%and variational set of attributes \vType\ 
%and
%2) there exists a valid variant in the intersection of variation context \vctx\
%and \vRel's presence condition \ensuremath{\dimMeta \wedge \VVal \dimMeta \wedge \getPC \vSch},
%then query \vRel\ has type \ensuremath {\annot [\vctx \wedge \VVal \dimMeta \wedge \getPC \vSch] \vType}.
% \ensuremath{\annot [\vctx \wedge \getPCfrom \vRelSch \vSch] \vType}.

% 
%The rule \prjE\ 
%checks that first, the subquery is well-typed (i.e., $\envPrime$);
%second, all projected attributes are present under the variation context 
%(i.e., $|\pushIn {\annot \vType}| = | \vType |$);
%third, projected attributes are subsumed by the type of the subquery
%(i.e., $\subsume { \vType}  {\pushIn {\annot [\VVal \vctx] {\VVal \vType}}}$).
%If all the premises hold, it returns the intersection of the projected attributes
%and the subquery attributes annotated with the presence condition of the
%subquery type (i.e., ${\envInContext [\VVal \vctx] {\left(\vType \cap {\VVal \vType} \right)}}$).
%%
%That is, it states that, in variation context \vctx\ within variational schema \vSch, assuming 
%that the subquery \vQ\ has type $\envInContext [\VVal \vctx] {\VVal \vType}$,
%variational query $\pi_\vType \vQ$
%has type \ensuremath {\envInContext [\VVal \vctx] {\left( \vType \cap \VVal \vType\right)}}, 
%if all attributes in \vType\ are present in \vctx\
%and
% \ensuremath {\pushIn {\envInContext [\VVal \vctx] {\VVal \vType}}} subsumes \vType.
%%
%Note that the variation context \dimMeta\ is applied in the presence condition of
%the subquery (\VVal \dimMeta), thus, there is no need to repeat it in the returned 
%type of the query $\pi_\vAttList \vQ$.
%%
%Assuming that $\VVVal \vType = \annot [\VVal \dimMeta] {\VVal \vType}$,
%the subsumption of $\subsume \vType { \VVVal \vType}$ is defined as
%\ensuremath{ \forall \annot [\dimMeta_1] \vAtt \in \pushIn {\vType}.
%\exists \dimMeta_2. \annot [\dimMeta_2] \vAtt \in \pushIn {\VVVal \vType}, 
%\sat {\dimMeta_2 \wedge  \dimMeta_1}} and it 
%ensures that the subquery \vQ\ does not have an empty type
%and it includes all attributes in 
%the projected attribute set and attributes' presence conditions do not 
%contradict each other. 
%Returning the intersection of types, defined in 
%\defref{vset-intersect}, filters both 
%attributes and their presence conditions.
%\exref{type} illustrates how the type system generates a type for a query
%and how this type helps enforcing the variation encoded in the query to its result.
For a projection $\vPrj[A]{q}$, the rule \prjE\ checks that all projected
attributes $A$ are present in at least one variant of the variation context
(second premise) and that these attributes are \emph{subsumed} by type of the
subquery $q$ (third premise).
%
The subsumption relation \subsume{A}{A'} used in the third premise is defined
as
%
$\forall \annot[e_1]{a} \in \pushIn{A}.
 \exists e_2.
 \annot[e_2]{a}\in\pushIn{A'}, \sat{e_1 \wedge e_2}$,
%
which ensures that all of the projected attributes are present in the type of
the subquery $q$, and that the presence conditions of the variational set of projected
attributes do not contradict the presence conditions in the type of $q$.
%
The result type is the variational set intersection (\figref{vset}) of the
projected attributes and the attributes of the subquery ensuring that the
variation constraints of both are captured.
%
\exref{type} illustrates how the type system infers a type for a variational query.


%
The rule \selE\ checks if its subquery and variational condition are well-typed
and if so it returns the subquery's type. 
%
% That is, it states that, in \vctxTxt\ \vctx\ within variational schema \vSch, assuming 
% that the subquery \vQ\ has type {\envInContext [\VVal \vctx] \vType}, 
% the variational query $\sigma_{\vCond} \vQ$
% has type {\envInContext [\VVal \vctx] \vType},
% if the \vCondTxt\ \vCond\ is \emph{well-formed} w.r.t.
%  \vctxTxt\ \vctx\ and  normalized type {\pushIn {\envInContext [\VVal \vctx] \vType}}, 
% denoted by variational condition's typing relation 
% \envCondAnnot \vCond.
%
The variational condition typing relation is defined in \figref{vq-stat-sem} and has the 
judgment form \envCond \vCond, which states that the variational condition \vCond\
is well-formed in variation context \vctx\ within attribute variational set \vType.
% Remember that  {\pushIn {\envInContext [\VVal \vctx] \vType}} normalizes 
% {\envInContext [\VVal \vctx] \vType} to be a variationalset.
The variational condition typing rules ensure that each attribute used in a
variational condition is present in \vType\ and that the presence condition associate with
that attribute does not contradict the current variation context.
%The rule \selE\ checks if its subquery and variational condition are well-typed
%and if so it returns the subquery's type. 
%%
%That is, it states that, in variation context \vctx\ within variational schema \vSch, assuming 
%that the subquery \vQ\ has type {\envInContext [\VVal \vctx] \vType}, 
%the variational query $\sigma_{\vCond} \vQ$
%has type {\envInContext [\VVal \vctx] \vType},
%if the variational condition \vCond\ is \emph{well-formed} w.r.t.
% variation context \vctx\ and  normalized type {\pushIn {\envInContext [\VVal \vctx] \vType}}, 
%denoted by variational condition's typing relation 
%\envCondAnnot \vCond.
%%
%The variational condition typing relation, as defined in \figref{vq-stat-sem}, has the 
%judgement form \envCond \vCond, which states that the variational condition \vCond\
%is well-formed in variation context \vctx\ within attribute variational set \vType.
%Remember that  {\pushIn {\envInContext [\VVal \vctx] \vType}} normalizes 
%{\envInContext [\VVal \vctx] \vType} to be a variational set.
%The variational condition typing rules state that attributes used in a
%variational condition must be present in \vType\ and 
%attribute's presence condition \ensuremath {\VVal \dimMeta} 
%in type \vType\ must exists within variation context \vctx,
%denoted by \ensuremath{\sat {\VVal \dimMeta \wedge \vctx}}.


For a choice of queries $\chc[e']{q_1,q_2}$, the rule \choiceE\ recursively
infers the type of each alternative subquery in a variation context extended to
reflect which branch of the choice the subquery is contained in, that is, $e'$
for $q_1$ and $\neg e'$ for $q_2$.
%
The result type of a choice is the variational set union (\figref{vset}) of the
types of the subqueries annotated by the disjunction of their presence
conditions, reflecting that either one alternative will be chosen or the other.
%
Note that \choiceE\ is the only rule that refines the variation context.


The \empRelE\ rule states that an empty relation has the type of an empty set
annotated by \f, which is the required base case to ensure that the type system
is variation preserving (see \secref{var-pres}).
%
The remaining rules are straightforward extensions of the standard relational
algebra typing rules for product and set operations to account for variation
contexts and variational sets.
%
%%
%The rule \choiceE\ adjusts the variation contexts of its alternative 
%subqueries, checks if they are both well-typed, and if so it returns
%the union of their types annotated with the disjunction of their presence conditions. 
%%
%That is, it states that, in variation context \vctx\ within variational schema \vSch, the type of 
%a choice of two subqueries is the \emph{union of types}, defined in 
%\defref{vset-union}, of its subqueries annotated with the disjunction of their presence
%conditions conjuncted with the corresponding condition of the choice's dimension.
%%A choice query is well-typed iff both of 
%%its subqueries $\vQ_1$ and $\vQ_2$ are well-typed.
%%
%Note that \choiceE\ is the only rule that refines the variation context and that 
%mainly uses the \empRelE\ rule which states that an empty relation has the 
%type of an empty set annotated with \f.
%%
%The rest of the rules are congruence rules for product and set operations over queries. 

% 
%The rule \productE\ states that the type of a product query in variation context
%\vctx\ is the union of the type of its subqueries annotated with the 
%disjunction of their presence conditions, assuming that 
%they are disjoint. 
%%Note that 
%%\ensuremath{
%%\annot [\vctx_1 \wedge \vctx_2] {\left(\envInContext [\vctx_1] \vType_1 \cup \envInContext [\vctx_2] \vType_2\right)}
%%\equiv 
%%\envInContext [\vctx_1 \wedge \vctx_2] \vType_1 \cup \envInContext [\vctx_1 \wedge \vctx_2] \vType_2
%%\equiv
%%\annot [\vctx_1 \wedge \vctx_2] {\left(\vType_1 \cup \vType_2\right)}
%%}.
%
%% 
%The rule \setopE\ denotes the typing rule for set operation queries such as 
%union and difference. It states that, if the subqueries $\vQ_1$ and $\vQ_2$
%have \emph{equivalent} types $\envInContext [\vctx_1] \vType_1$ and 
%$\envInContext [\vctx_2] \vType_2$
%%, respectively, 
%in variation context \vctx,
%then the variational query of their set operation has type $\envInContext [\vctx_1] \vType_1$.
%%, iff 
%%$\pushIn {\envInContext [\vctx_1] \vType_1}$ and $\pushIn {\envInContext [\vctx_2] \vType_2}$ are \emph{equivalent}.
%The \emph{type equivalence} is variational set equivalence, defined in \defref{vset-eq}, for normalized variational set of attributes.
%%,
%%for variational sets of attributes.

\begin{example}
\label{eg:type}
Consider the query \ensuremath{\vQ_1} given in \exref{vq-specific}.
Through this example, we simplify feature expressions when possible.
First, the \prjE\ rule is applied which requires the three premises to 
hold:
The first one looks up the type of \empbio\ relation from the underlying
variational schema (Assumption 1 in \figref{vq1-type}). The second one 
checks for the subsumption of the projected attributes from the type of 
the subquery (Assumption 2 in \figref{vq1-type}). The last one ensures
all projected attributes are valid under the current variation context
(Assumption 3 in \figref{vq1-type}). Since all premises hold the type of
the query is generated as shown in \figref{vq1-type}:
\[
\annot [\dimMeta_2] {( \annot [(\vFour \vee \vFive) ] \empno, \annot [\vFour] \name, \annot [\vFive] \fname, \annot [\vFive] \lname)} 
\]
% under
%the variation context initiated to 
%\ensuremath{\fModel_2 = \vThree \oplus \vFour \oplus \vFive}
%and schema \ensuremath{\vSch_2}.
%Now the
%\relationE\ rule applies to the subquery \ensuremath {(\empbio)} 
%under the same variation context and schema,
%resulting in the type
%\ensuremath{
%\vAttList_\empbio =  \{\empno, \sex, \birthdate,}
%\ensuremath{ 
%\optAtt [\vFour] [\name], \optAtt [\vFive] [\fname], \optAtt [\vFive] [\lname]\}^{\fModel_2}}.
%Now that the type system has the type of the subquery \empbio\ 
%it verifies that the projected attribute variational set
%\ensuremath{
%\vAttList_{\mathit{prj}} =
% \{\optAtt [\vFour \vee \vFive] [\empno],
%\name,}
%\ensuremath{ \fname, \lname\}^{\fModel_2}},
%is subsumed by \ensuremath{\vAttList_\empbio}. 
%Thus, it generates the type of \ensuremath{\vQ_1} by
%intersecting \ensuremath{\vAttList_{\mathit{prj}}} and \ensuremath{\vAttList_\empbio}
%annotated with \ensuremath{\vAttList_\empbio}'s presence condition, resulting in the type
%\ensuremath{
%\vAttList_{\vQ_1} = 
%\{\optAtt [\vFour \vee \vFive] [\empno],
%\optAtt [\vFour] [\name], }
%\ensuremath{
%\optAtt [\vFive] [\fname], \optAtt [\vFive] [\lname]\}^{\fModel_2}}.
%%
%This type proves that $\vQ_1$ is well-typed and dictates the structure of its result.
%\ensure{don't forget to inlcude this}
%\figref{vq1-type} illustrates the tree derivation of $\vQ_1$'s type.

\input{formulas/typeSysEx1}
%
Now consider \ensuremath{\vQ_2} introduced in \exref{vq-specific}.
First, the \choiceE\ rule is applied which requires two premises to hold:
The first one checks that the left alternative (which then applies the \prjE\ rule) 
of the choice is type-correct, in which 
case it also generates its type (Assumption 5 in \figref{vq2-type}).
The second one does the same for the right alternative which is an empty relation 
query and is always type-correct. Since both alternative are type-correct the type 
of the query is generated as shown in \figref{vq2-type}:
\[
\annot [(\dimMeta_2 \wedge (\neg \vThree)) \vee \texttt{false}] {( \empno, \annot [\vFour] \name, \annot [\vFive] \fname, \annot [\vFive] \lname)}
\]
%under the variation 
%context initiated to \ensuremath{\fModel_2} and schema \ensuremath{\vSch_2}.
%It then applies the \prjE\ and \empRelE\ rules to the left and right
%alternatives of the choice, respectively, which generates the types
%\ensuremath{
%\vType_\mathit{left} = \annot [\fModel_2 \wedge (\vFour \vee \vFive)] {(\empno, \annot [\vFour] \name,
% \annot [\vFive] \fname,\annot [\vFive] \lname)}}
%and \ensuremath{\vType_\mathit{right} = \annot [\f] {\setDef \ }}, respectively.
%Finally, it generates the type of \ensuremath{\vQ_2} by 
%annotating the union of \ensuremath{\vType_\mathit{left}} and \ensuremath{\vType_\mathit{right}}
%with \ensuremath{\fModel_2 \wedge (\vFour \vee \vFive)}, resulting in the 
%final type of \\
%\ensuremath{\vType_{\vQ_2} = 
%\annot [\fModel_2 \wedge (\vFour \vee \vFive)] {(\empno, \annot [\vFour] \name,
% \annot [\vFive] \fname,\annot [\vFive] \lname)}}.
% Note that \ensuremath{\vType_{\vQ_2}}'s presence condition 
% explicitly accounts for only two variants
% while \ensuremath{\vType_1} does not do so even though \ensuremath{\vQ_1}
% does not return any tuple that belongs to variant \ensuremath{\setDef \vThree} because
% of its attributes presence condition.
% \ensure{don't forget to inlcude this}
% \figref{vq2-type} illustrates the tree derivation of $\vQ_2$'s type.
%
 \input{formulas/typeSysEx2}
%
\end{example}

\newpage


%9-19-18 notes:
%* type soundness theorem: 
%    * ideally we want to prove this, but at least we should formulate it
%    * the way you do this usually, is that you have a semantics and you want to show 
%        * progress: if your program is well-typed your either done evaluating it or you can keep evaluate it -> in our case is kind of given, because we don't have a turing complete language!!
%        * preservation: when we evaluate sth it doesn't change its type! -> what we want to show is the relation that semantics gives us back fits the schema that the type system gives us. so there is consistency between type system and semantics. 
%    * so in the context of variational queries what that would mean is that when we evaluate a query, the relation that we get back actually has the type that we said it has via the type system
%    * PROBLEM: our semantics is via SQL so proving this will be kind of hairy but we should at least write this down and try to convince ourselves that it's correct, and we'll figure out what we can say in the context of the paper.
%    * [TODO] writing test cases that it?s correct!! in terms of mini database at two levels, haskell and database. the test cases will be queries against this mini database with lots of variability in it. you can write a quick check property. so you basically are testing the commuting diagram, so you either:
%        1. configure the query first and then give its type
%        2. give its variational type first and then configure it
%        3. and you should get the same thing from both
 


%The purpose of establishing \emph{type safety} is to ensure that the
%static and dynamic semantics are consistent with each other. 
%@Eric do we need to say anything about why we don't take the standard 
%approach?
%\NEED{Since 
%we define \vqTxt\ dynamic semantics in terms of relational algebra,
%i.e. we translate a \vqTxt\ into a set of relational algebra expression 
%and then combine the result of them into a \vrelTxt, we do not take 
%the standard approach of defining and proving \emph{progress} and 
%\emph{preservation} properties.
%}

%We 
%follow the approach developed by \TODO{fill in later!!}, which distinguishes
%two type safety properties, preservation and progress. The preservation
%theorem establishes that \vqsTxt\ preserve type assignments, i.e. that the
%type of a \vqTxt\ accurately predicates the type of the result of evaluating 
%that \vqTxt. \TODO{state the context and type you start out with}


%pierce def:
%progress: a well-typed term is not stuck (either it is a value or it can take a step 
%according to the evaluation rules)
%\begin{theorem}
%\label{thm:progress}
%Suppose \vQ\ is a closed, well-typed \vqTxt\ (that is, \env {\vQ} {\vType} for some 
%\vType). Then either \vQ\ is a value (a \vrelTxt ) or else there is some 
%\TODO{in order to define this we need to define:\\
%small step of relational algebra\\
%translation rules to rel alg\\
%combining the set of queries resulted from translation to output a var table\\
%canonical forms\\
%
%\end{theorem}


%pierce def:
%preservation: if a well-typed term takes a step of evaluation, then the resulting 
%term is also well typed
%\begin{theorem}
%\label{thm:type-pres}
%
%\end{theorem}

%\TODO{double check the following ph and write the properties based on it:}
%Conceptually, a variational query describes a query that can
%be executed over any database instance consistent with the 
%variational schema. The property that must hold between a 
%variational query \vQ\ and a variational schema \vSch
%is that for every plain query $\pQ_\config$ obtained from \vQ 
%by configuring with a function $\config: \fSet \to \bSet$, $\pQ_\config$ 
%is consistent with the corresponding plain schema $\pSch_\config$ 
%obtained by $\osSem  \vSch$ with the same function \config. That 
%is, every variant query matches the corresponding variant schema.
%%\REMEMBER{In \secref{prop-q-lang}, we prove that our query language,
%%variational relational algebra, can encode this idea and also
%%recover any of the conceptually potential results for any instance
%%of the variational database.}
