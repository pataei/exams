\section{Discussion: Should Variation Be Encoded Explicitly in Databases?}
\label{sec:usecase-disc}
In this section we discuss the use cases and our encodings of VDB and variational queries
in the context of the question posed in the title of this paper: \emph{Should
variation be encoded explicitly in databases?}

% \subsection{Expressiveness of Explicit Variation}
% \label{sec:dis:good}

\paragraph{Expressiveness of explicit variation.}
%
The use cases in \chref{vdbusecase} show that by treating
variation as an orthogonal concern and embedding it directly in databases and
queries (via presence conditions and choices), one can encode data variation
scenarios in both time and space.
%
In fact, VDBs and variational queries are \emph{maximally expressive} in the sense that
any set of plain relational databases can be encoded as a single VDB and any
set of plain queries over the variants of a VDB can be encoded as a variational query.%
%
\footnote{The expressiveness of VDBs and variational queries can be proved by
construction. For VDBs, one can simply take the union of all relations,
attributes, and tuples across all variants, then attach presence conditions
corresponding to which variants each is present in. For variational queries, all variants
can be organized under a tree of choices that similarly organizes the variants
in the appropriate way.}


The expressiveness of our approach is its main advantage over other ways to
manage database variation. When working with a form of variation that already
has its own specialized solution (e.g.\ schema evolution, data integration),
the expressiveness of explicit variation is probably not worth the additional
complexity.
%
The expressiveness of explicit variation is most useful when working with a
form of variation that is not well supported (e.g.\ query-level variation in
SPLs), or when combining multiple forms of variation in one database (e.g.\
during SPL evolution).


We expect that ill-supported forms of variation are common in industry and
justify the expressiveness of explicit variation. For example, the following is
a scenario we recently discussed with an industry contact:
%
A software company develops software for different networking companies and
analyzes data from its clients to advise them accordingly. 
%
The company records information from each of its clients' networks in databases
customized to the particular hardware, operating systems, etc.\ that each
client uses.
%
The company analysts need to query information from all clients who agreed to
share their information, but the same information need will be represented
differently for each client.
%
This problem is essentially a combination of the SPL variation problem (the
company develops and maintains many databases that vary in structure and
content) and the data integration problem (querying over many databases that
vary in structure and content). However, neither the existing solutions from
the SPL community nor database integration address both sides of the problem.
%
Currently the company manually maintains variant schemas and queries, but this
does not take advantage of sharing and is a major maintenance challenge.
% , for the reasons SPL researchers are familiar with.
%
With a database encoding that supports explicit variation in schemas, content,
and queries, the company could maintain a single variational database that can
be configured for each client, import shared data into a VDB, and write
variational queries over the VDB to analyze the data, significantly reducing redundancy
across clients.
%
% While this scenario uses all of the features of VDBMS, we expect one can
% still benefit by using only a subset of its features.


% \subsection{Complexity of Explicit Variation}
% \label{sec:dis:bad}

\paragraph{Complexity of explicit variation.}
%
The generality of explicit variation comes at the cost of increased complexity.
The complexity introduced by presence conditions and choices is similar to the
complexity introduced by variation annotations in annotative approaches to SPL
implementation~\cite{KAK08}. There is widespread acknowledgment that
unrestricted use of variation annotations, such as the C Preprocessor's \cpp{ifdef}-notation~\cite{cpp}, makes software difficult to understand~\cite{LWE11vl} and
is error prone~\cite{FMKPA:SPLC16}.
%
However, so-called \emph{disciplined} use of variation annotations, where
annotations are used in a way that is consistent with the object language
syntax of variants, may suffer less from such issues~\cite{LKA:AOSD11}. In
VDBs, and in the VRA notation for variational queries, annotations are disciplined since
presence conditions and choices are integrated into the existing syntax of
relational database schemas and relational algebra.
%
Note that annotation discipline is not enforced in the \cpp{ifdef}-annotated SQL
notation that we use to distribute the variational queries associated with our use cases.


Subjectively, the development of our use cases suggests that the impact
of variation annotations on understandability is moderate for variational schemas and
VDBs, and significant for variational queries written in VRA, despite the fact that such
annotations are disciplined.
%
% Maybe cut this chunk:
%
 That is, we believe that presence conditions make clear the structural and
 content variation in our example VDBs without significantly impacting the
 understandability of the overall structure and content of the variant
 databases. However, the understandability of variational queries do seem to be
 significantly impacted by the use of presence conditions and choices, despite
 the fact that their use is disciplined in the VRA notation.


It is possible that a more restrictive and/or coarse-grained form of variation
in variational queries would make them easier to understand at the cost of increased
redundancy and (potentially) reduced expressiveness.
%
This tradeoff is one we already made when considering how to encode variation
in the \emph{content} of a VDB. Specifically, we do not support cell-level
variation in a VDB (e.g.\ choices within individual cells). This does not
reduce the expressiveness of content variation in VDBs since cell-level
variation can be simulated by row variation, but it does increase redundancy
since all non-varied cells in the row must be duplicated.
%
Similarly, variation in queries could be restricted to expression-level
choices, with no choices or annotations in conditions or attribute lists. This
would likely make understanding individual query variants easier at the cost of
increasing redundancy among the alternatives of each choice.


Alternatively, the understandability of variational queries could be improved through
tooling, for example, using background colors~\cite{feigenspan2013}, virtual
separation of concerns~\cite{KA09}, or view-based
editing~\cite{WO14gpce,SBWW16icsme}.
%
Future work should validate our subjective assessment of the understandability
VDBs and variational queries, and explore techniques for improving this concern.


% The additional expressiveness of a database and query language allowing users
% to express the variation appearing in their specific use case is essential to
% databases and users information needs. 
% %
% If you are dealing with a kind of variation that has its own specialized
% solution you probably prefer to use that, e.g., you have a database that
% evolves over time. However, if you are dealing with a kind of variation or
% combination of different kinds of variations in your database that does not
% have a specialized solution or system to it you want to be able to configure a
% generic database to your variational need instead of developing a database
% system for your specific use from scratch. That is basically what VDB does: it
% provides users with a generic framework that allows them to configure it to
% their need and benefit from its capabilities that matches their need. 

% \edit{
% The following scenario resulted from our conversation with industry.
% Consider a software company that develops software for 
% different networking companies and analyzes data from its clients to 
% advise them accordingly. 
% %
% This company uses a database to store information that it extracts from 
% each of its clients network, however, since different clients use different 
% hardware and operating systems it needs to store different information
% for each client. 
% %
% At the same time, the company analyzers need to query information
% from all clients who agreed to sharing their information. This results
% in a huge problem since each client has its own database and schema,
% thus, analyzers cannot put all clients databases in a single database. 
% %
% Currently and in practice, developers fix a schema and force all their data
% into that schema. This approach is messy and inefficient. It also creates
% lots of manual burden for developers and DBAs. 
% %
% However, by using VDB the developers can avoid lots of unnecessary work since
% }
% 
% \begin{itemize}
% \item \edit{A VDB can be configured for this scenario by creating the feature space and the v-schema.}
% \item \edit{Individual databases can be deployed for each client.}
% \item \edit{The VDB that contains information from all clients can be queried using VRA.
% These queries allow analyzers to compare different networks (variants) in addition to allowing
% developers to write v-queries in their programs instead of manually rewriting queries for each client
% such that it matches the correct schema. }
% \item \edit{Clients can still query their individual database using SQL. So they do not need to learn a new language.}
% \item \edit{Developers can express properties of each (or some) variant(s).}
% \end{itemize}
% 
% \edit{
% Note that this scenario uses all that VDB has to offer, however, one can also benefit
% from some of VDB's features and not all of them. 
% }


\paragraph{Analyzability of explicit variation.}
%
The relationship of our work to alternative approaches can be viewed through
the lens of annotative vs.\ compositional variation, familiar to the SPL
community~\cite{KAK08}.
%
VDBs and variational queries rely on generic annotations embedded directly in schemas and
queries, respectively, while approaches from the databases community often
express variation through separate artifacts, such as views~\cite{bancilhon81}.
%
Annotative vs.\ compositional representations often exhibit the same tradeoff
between expressiveness and complexity described above: annotative variation
tends to be general and expressive, while compositional variation tends to be
more restrictive but support modular reasoning~\cite{KAK08}.
%
Traditionally, another advantage of compositional approaches is that they are
more analyzable thanks to the ability to analyze components separately (i.e.\
\emph{feature-based} analysis~\citep{Thuem14}), a benefit shared by database
views.
%
However, in the last decade there has been a significant amount of work in the
SPL community to improve the analyzability of annotative variation by analyzing
whole variational artifacts directly (i.e.\ \emph{family-based}
analysis~\cite{Thuem14}). 
%
Although not presented here, we build directly on this body of work, especially
work on variational typing~\cite{CEW12icfp,CEW14toplas}, to enable efficiently
checking variational queries against all variants of a VDB, among other properties.
%
Thus, the increased complexity of explicit variation annotations does not
prevent us from verifying its correctness.

% Historically, a disadvantage of annotative variation is that it was impossible
% to ensure safety properties for all variants of a variational program since the
% number of variants grows exponentially and such properties could only be
% checked variant-by-variant (i.e.\ via product-based analysis~\cite{Thuem14}).
%
% This was in contrast to some compositional approaches to
% variation~\cite{KAK08}, which supported separately analyzing components and
% their compositions (i.e.\ feature-based analysis~\cite{Thuem14}). However,
% compositional approaches typically have the drawback of being less general than
% annotative ones, supporting only certain kinds and often courser-grained
% variability~\cite{KAK08}.


%As can be seen in \secref{db} and \secref{q}, treating variability as an
%orthogonal concern and encoding it directly in databases and their queries 
%
%It is general in the sense
%that any set of variant databases can be encoded as a VDB, and it enables
%directly associating variation in the databases to variation in software.
%
%Variational typing techniques developed in the SPL community.

%\textbf{Is it a good idea to explicitly encode variability in databases?}

\begin{comment}

\textbf{What is the role of the use cases in advancing variation research?}
%
They  illustrate the process of explicitly encoding
variation in the database and queries in \secref{db} and \secref{q}, respectively. 
%
The first step 
is recognizing features involved in the variational scenario. 
A feature is a trait that is essential for convey some information
need. 
%
Thus, for each feature, one should (1) enumerate the operations that must be supported both
to implement the feature itself and to resolve undesirable feature
conflicts, (2) identified the information needs to implement these
operations, and (3) map features to database elements accordingly.
%extended the variational schema to satisfy these
%information needs.
%
This process outlines generating the variational schema for a variational
scenario as show cased for our \edit{use cases} in 
\secref{emp-vsch} and \secref{enron-vsch}.
%
%
It is easy to generate a VDB from a set of 
database variants with their corresponding configuration.
However, we generated our VDBs from scratch, that is,
we did not have any database variants and their corresponding
configuration. \edit{Our attempts at generating the use cases are 
a sample of the burden that developers and DBAs have undergo
in order to manage variability in a database that cannot represent
variation, however, our attempts result in building a database that
can represent variation and thus reduces any future burden as 
compared to a traditional database where DBAs have to deal with 
variation constantly.}

\end{comment}


%\textbf{How can the introduced case studies help evaluating VDBMS?}
%what can these case studies be used for to evaluate VDBs?
%--> the merit of using them to evaluate our tool?
%     what are the question we intend to answer with our tool?
%Studying the cases helped us understand the flow of
%data and the query through VDBMS better and allowed us to refactor
%our data types to achieve a more useable and understandable encoding. 
%%
%We are using the introduced \edit{use cases} to debug and evaluate the
%performance of different approaches implemented in VDBMS 
%for running a variational query on a VDB. Profiling the result
%of said evaluation will help us recognize where we can optimize
%our system. 
%%
%Additionally, we expected our language to be more useable, readable, and
%easier to understand. However, we realize that there is a buy-in cost
%for programmers to pay when they first learn the language. Furthermore,
%the variation in queries may get complicated, yet the programmer can 
%still express their information need the way they are most comfortable
%since variability flows in different parts of a query as shown in \secref{emp-qs}, 
%that is, the overall query
%can be wrapped in a choice, attributes can be projected variationally and
%conditions can be encoded variationally. 
%Still, we believe that the expressiveness of our
%language allows for type checking queries (with variation encoded in them)
%even though it adds more complexity 
%to the language.

%\textbf{How can other researchers benefit from the introduced case studies?}
%
%
%The \edit{use cases} provide an accessible example of how one can encode different 
%kinds of variability in a database using a VDB. This allows one to have a 
%starting point for attacking a new kind of variability appearing in databases,
%e.g., one could have used the employee \edit{use case} to attack database 
%evolution without developing an entirely new system. For example, 
%we suspect that VDBs can be used to also model database 
%versioning~\cite{datasetVersioning,dbVersioning} and
%data provenance~\cite{bt07sigmod}. Such applications can be pursued in future.
%%
%Additionally, the distribution of our databases and queries in a generic
%manner allows others to parse them easily to fit their research.
% %
%Furthermore, these \edit{use cases} can be used to emulate the encoding of 
% variation within other sorts of data such as spreadsheets.
 
 
%\textbf{What are the lessons learned while generating these case studies?}
%do they illustrate common challenges/problems when handling variational data?
%
%Beyond the use of these studies for development of our system,
%%The case studies 
%they illustrate that the most critical step of
%generating a VDB is recognizing the features and configurations
%in order to correctly encode variability of each variant.
%
%Encoding variation explicitly in both the database and the query
%provides developers with tracing variation and connecting
%the variation in data to variation in software development.
%For example,
%the ability to check properties over data as mentioned in
%\secref{prop} is really useful for debugging the
%human mistakes. Similarly, the type system ensures that 
%queries do not contain undesired behavior. 
%%
%Thus, we believe that explicitly
%encoding variability in the data and the queries gives developers the 
%power of testing properties that otherwise would not be possible. 
%This is arguably the strongest advantage of VDBs. Recently
%lots of attempts have been done
%on statically analysis, theorem proving, model checking, and program verification
%of variable programs and 
%variable structure~\cite{brkts20vamos, bks11fvoos, ldl07jss, tmbhvs14}, especially 
%for safety-critical systems,
%\eric{Eric, feel free to add other related work to support this argument.}
% and since databases are part of 
%software system the ability to analyze, check, and verify 
%properties over variational databases provides programmers
%with a seamless framework where they can verify software
%and its artifacts.
%


%%\textbf{What are the future research directions?}
%The \edit{use cases} can be used to develop further research directions
%to make programming with variational databases easier and safer.
%%
%%The first direct future work following these case studies is generating
%%a VDB automatically from a set of databases with their corresponding
%%configuration. 
%%\parisa{remove this if we have a semi-auto gen vdb approach.}
%%
%%considering the new complexity and expressiveness added 
%%to the language (explicit encoding of variability), 
%For example, one can extend the query language with holes and even suggestions for 
%the holes would make programmers job easier in both writing queries
%and debugging them.
%%
%It will be very interesting to see the application of VDBs and 
%variational queries in software testing.
%
%%\end{comment}

