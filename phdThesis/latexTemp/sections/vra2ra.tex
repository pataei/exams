\subsection{VRA Configuration}
\label{sec:vraconf}

\input{formulas/vRelAlgConfSem}

%\NOTE{
%Also, the following definition of the semantics contradicts with the
%description earlier in the section about producing a \emph{result}
%relation.
%
%\medskip
%Also also, maybe we should move the discussion of the semantics before the
%examples? It's a bit surprising to come across it here.}

%The semantics of VRA can be understood as a combination of the
%\emph{configuration semantics} of VRA, defined in \figref{v-alg-conf-sem}, the
%configuration semantics of VDBs, defined in \figref{vdb-conf}, and the
%semantics of plain RA.
%%
%%\TODO{Make the following a more precise description of how these three
%%semantics work together, i.e.\ for every valid configuration of the feature
%%model, we can configure the variational query and VDB in the same way to yield a plain RA
%%query that is then executed over the corresponding plain RDB.}
%%
%Thus, the variational query
%semantics is the set of semantics of its configured relational queries over
%their corresponding configured relational database variant for every valid
%configuration of the feature model of the VDB.
%
%We now embark on the formal definition of variational queries configuration.
The \emph{configuration} function maps a variational query under
a configuration
to a relational query, defined in \figref{v-alg-conf-sem}. Thus, a variational query 
can be understood as a set of relational queries that their results is gathered
in a single table and tagged with the feature expression stating their variant.
%Configuring a variational query
%for all valid configurations, accessible from VDB's feature model,
%provides the complete meaning of a variational query in terms of RA semantics.
%
Users can deploy queries for a specific variant by configuring 
them.
%
%The configuration of a query allows users to deploy queries for a
%specific variant when they desire, 
%satisfying query part of \nThree\ requirement. 
\exref{conf-vq} illustrates configuring a query
and \exref{vq-sem} illustrates the configuration of query $\VVal {\vQ_1}$ from \exref{vq-specific} and their corresponding relational results table.

%\input{formulas/vCondConfSem}

%To define VRA semantics we map 
%a variational query to a pure relational query to re-use RA's semantics.
%However, to avoid losing the variation encoded 
%in the variational query, 
%we need to determine the variant under which such a
%mapping is valid. Thus, we introduce the semantic functions that 
%relate a variational query to a relational query.

%
%\textbf{Configuring a variational query:} 
%It maps a variational query under a 
%given configuration to a relational query, denoted by \eeSem . 
%and defined in \figref{v-alg-conf-sem}. Configuring a variational query
%for all valid configurations, accessible from VDB's feature model,
%provides the complete meaning of a variational query in terms of RA semantics.
%Users can deploy queries for a specific variant by configuring 
%them,
%%The configuration of a query allows users to deploy queries for a
%%specific variant when they desire, 
%satisfying query part of \nThree.

\begin{example}
\label{eg:conf-vq}
Assume the underlying VDB has the variational schema
% \t\ feature model and the variational relation
\ensuremath{
\vSch_3 = \{ \vRel \left( \optAtt [\fOne] [\vAtt_1], \vAtt_2, \vAtt_3 \right)^{\fOne \vee \fTwo}
\}} 
and the feature space 
\ensuremath{
\features = \setDef{ \fOne, \fTwo}}.
For valid configurations of this VDB (i.e., \setDef {\A, \B}, \setDef \A, \setDef \B, and \setDef {\ }), 
the variational query 
\ensuremath{
\vQ_5 = \vPrj [{\vAtt_1, \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] (\vRel)
}
is configured to the following relational queries:
\begin{alignat*}{1}
\eeSem [\setDef \fOne] {\vQ_5} &=  \pi_{\pAtt_1} \pRel\\
\eeSem [\setDef \ ] {\vQ_5} &= \pi_{\pAtt_1} \pRel\\
\eeSem [\setDef \fTwo] {\vQ_5} &= \pi_{\pAtt_1, \pAtt_3} \pRel\\
\eeSem [\setDef {\fOne, \fTwo}] {\vQ_5} &= \pi_{\pAtt_1, \pAtt_2, \pAtt_3} \pRel
\end{alignat*}
\end{example}





%\textbf{Grouping a variational query:} 
%maps a variational query to a set of
%relational queries annotated with feature expressions, denoted by \qGroup .
%and defined in \figref{vq-group}. The presence condition of relational queries 
%indicate the group of configurations where the mapping holds. In essence, 
%grouping of variational query \vQ\ groups together all configurations with the same relational
%query produced from configuring \vQ. 
%Hence, the generated set
%%\dropit{could drop this if it's confusing!}
%of relational queries from grouping a variational query contains distinct (unique) queries.
%For example, consider the query \ensuremath {\vQ_5} in \exref{conf-vq}.
%Grouping \ensuremath{\vQ_5} results in the set:
%\ensuremath{
%\setDef{
%\left( \pi_{\pAtt_1, \pAtt_2, \pAtt_3} \pRel \right)^{\fOne \wedge \fTwo},
%\left(\pi_{\pAtt_1, \pAtt_3} \pRel \right)^{\neg \fOne \wedge \fTwo},
%\left(  \pi_{\pAtt_1} \pRel \right)^{( \fOne \wedge \neg \fTwo) \vee (\neg \fOne \wedge \neg \fTwo)}
%}
%}.
%
%
%

\begin{example}
\label{eg:vq-sem}
Consider the query $\VVal {\vQ_1}$ given in \exref{vq-specific}: \\
\centerline{
$\VVal {\vQ_1} = 
\pi_{\optAtt [(\vFour \vee \vFive) \wedge \neg \vThree] [\empno], 
\optAtt [\vFour \wedge \neg \vThree \wedge \neg \vFive] [\name], 
\optAtt [\vFive \wedge \neg \vThree \wedge \neg \vFour] [\fname], 
\optAtt [\vFive \wedge \neg \vThree \wedge \neg \vFour] [\lname]} (\empbio)
$.}  
Configuring $\VVal {\vQ_1}$ for all valid configurations 
(\setDef \vThree, \setDef \vFour, \setDef \vFive) of the given VDB
results in three relational queries:
%
\begin{alignat*}{1}
%
\eeSem [\setDef {\vThree}] {\VVal {\vQ_1}} &= \empRel\\
%
\eeSem [\setDef {\vFour}] {\VVal {\vQ_1}} &= \pi_{\empno, \name} (\empbio)\\
%
\eeSem [\setDef {\vFive}] {\VVal {\vQ_1}} &= \pi_{\empno, \fname, \lname} (\empbio)
%
%\eeSem [\setDef {\ }] {\VVal {\vQ_1}} &= \empRel 
\end{alignat*}
%
\noindent
\tabref{vq-conf-res} shows the result of these relational queries.
\end{example}

\input{tables/vq-conf-res}


%\TODO{write this + correct formulas + give an example.
\eric{Eric, pls re-read the following up to Figure 4.3}
Often a variational query will yield the same plain query for multiple configurations.
For our semantics, it is useful to get the set of unique variants of a variational query.
%Unfortunately, the configuration of variational queries may result in
%duplicate relational queries. In practice, this is not very efficient, as discussed
%later in \secref{exp}. 
Thus, we define the \emph{unique variants} function, whose type is given below.
\[
\qGroup[\cdot]{\cdot} : \qSet \totype \settype \fSet \totype \settype {\bm{(} \vartype \pQSet \bm{)}}
\]
This function takes a variational query and VDB's set of features
and returns a set of configured relational queries annotated with
a presence condition. The presence condition is a feature expression generated from
the set of configurations that configured the variational query into the same relational query.
To generate this presence condition from configurations we need to know the closed 
set of VDB's features.
%
This is done by the $\mathit{genFexp} (\config,\features)$ that takes a configuration and a closed set of 
features and generates the feature expression \dimMeta\ that is only satisfiable by the configuration
\config. For example, $\mathit{genFexp} (\setDef {\A},\setDef {\A, \B}) = \A \wedge \neg \B$ and
$\mathit{genFexp} (\setDef {\A, \B},\setDef {\A, \B}) = \A \wedge \B$.
%
Remember that the set of enabled features of a configuration denote the said configuration,
for example, $\setDef {\A}$ denotes the configuration in which only feature \A\ has been 
enabled.

%
In essence, the unique variants function can be defined for all data types that encode variation.
For example, the unique configuration function for 
variational queries can be defined as follows.
\begin{alignat*}{1}
\qGroup{\vQ} &=
  \{ \pQ^{e_1 \vee\ldots\vee e_n}
     \myOR \pQ^{e_1}, \ldots, \pQ^{e_n}
       \in \{ (\eeSem{\vQ})^{\mathit{genFexp}(\config,\features)}
         \myOR \config\in\confSet \} \}
% \qGroup \vQ &= \{ \annot \pQ \myOR \dimMeta = \bigvee_{\dimMeta_i \in \mathit{es}} \dimMeta_i,
% \mathit{es} = \{\dimMeta_i \myOR \forall \config \in \confSet. \eeSem \vQ = \pQ, 
% \dimMeta_i = \mathit{genFexp} (\config,\features) \}\\
% &\hspace{50pt}, \exists \config \in \confSet. \fSem \dimMeta = \t, \eeSem \vQ = \pQ
% \}
\end{alignat*}
%\centerline{
%\ensuremath{
%\qGroup \vQ = \setDef {\annot \pQ \myOR \forall \config \in \confSet: \fSem \dimMeta = \t,
%\eeSem \vQ = \pQ}
%}.}
%\]
The unique configuration for variational sets of attributes
($\aG(\cdot,\cdot)$) and variational conditions ($\cG(\cdot,\cdot)$) are
defined similarly; their types are given below.
\begin{alignat*}{1}
\aG(\cdot,\cdot) &:
  \vAttSet \totype \settype \fSet \totype {\vartype {\bm{(}\settype \attnametype \bm{)}}} \\
\cG(\cdot,\cdot) &:
  \vCondSet \totype \settype \fSet \totype \vartype \pCondSet
\end{alignat*}
%
However, the definition of $\qGroup[\cdot]{\cdot}$ is not efficient since it
still enumerates all possible 
configurations. Thus, we define the more efficient unique configuration function
for variational queries in \figref{vq-group}.
%
%\exref{group-vq} and \exref{vq-group} provide the unique configuration of the queries 
%given in \exref{conf-vq} and \exref{vq-sem}, respectively.

\input{formulas/groupVqDef}

\begin{example}
\label{eg:group-vq}
Consider the query \ensuremath{
\vQ_5 = \vPrj [{\vAtt_1, \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] (\vRel)
}
given in \exref{conf-vq}. The unique configuration of this query results in the following set of queries:
%
\[
\qGroup [\{\A,\B\}] {\vQ_5} = \setDef {
\annot [(\A \wedge \neg \B) \vee (\neg \A \wedge \neg \B)] {(\pi_{\pAtt_1} (\pRel))},
\annot [\neg \A \wedge \B] {( \pi_{\pAtt_1, \pAtt_3} (\pRel))},
\annot [\A \wedge \B] {(\pi_{\pAtt_1, \pAtt_2, \pAtt_3} (\pRel))}
}.
\]
\end{example}

\begin{example}
\label{eg:vq-group}
Consider the query $\VVal {\vQ_1}$ configured in \exref{vq-sem}:\\
\centerline{
$\VVal {\vQ_1} = 
\pi_{\optAtt [(\vFour \vee \vFive) \wedge \neg \vThree] [\empno], 
\optAtt [\vFour \wedge \neg \vThree \wedge \neg \vFive] [\name], 
\optAtt [\vFive \wedge \neg \vThree \wedge \neg \vFour] [\fname], 
\optAtt [\vFive \wedge \neg \vThree \wedge \neg \vFour] [\lname]} (\empbio)
$.}  
The unique configuration of it results in:
\begin{alignat*}{1}
\qGroup [\{\vThree, \vFour, \vFive \}] {\VVal {\vQ_1}} &= \{
\annot [\vThree \wedge \neg \vFour \wedge \neg \vFive] {\empRel},
\annot [\neg \vThree \wedge \vFour \wedge \neg \vFive] {\left(\pi_{\empno, \name} (\empbio)\right)}\\
&\qquad ,\annot [\neg \vThree \wedge \vFour \wedge \neg \vFive] {\left(\pi_{\empno, \fname, \lname} (\empbio) \right)}\}.
\end{alignat*}
\end{example}


