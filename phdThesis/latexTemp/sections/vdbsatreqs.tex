\section{How VDB Satisfies These Requirements}
\label{sec:vdb-sat-req}


\NOTE{The explanation in the following two paragraphs is really hard to follow.
Some ideas for improvement: (1) State the requirement that you're talking about
first, then explain how VDB satisfies it; currently the requirement comes at
the end, so for 1--3 sentences the reader is wondering why you're re-hashing
this aspect of VDB. (2) The reader has forgotten by now what the requirements
are, so a brief (few words) description is needed for each requirement as you
discuss it. (3) It would help to follow the same order of requirements as
\secref{mot} as closely as possible. 

\medskip
I recommend structuring this discussion more rigidly as, ``This encoding
satisfies \nZero, which is about foo, by doing bar. It satisfies \nOne, which
is about blah, by doing baz.'' Obviously there's plenty of room for making it
read more nicely than that, but the lack of structure is making it hard to
understand as-is.}


This encoding of variational databases satisfies the requirements for a
variational database described in \secref{mot}. Similar to a variational schema, a user
can configure a variational table or a VDB for a specific variant, formally defined in
\figref{vdb-conf} in \appref{vdb-conf}. This allows users to deploy a VDB for a
specific configuration and generate the corresponding VDB variant, satisfying
database part of \nThree\ need.
%
Additionally, 
our VDB framework puts all variants of a database into
one VDB (satisfying \nZero) 
and it keep tracks of which variant a tuple belongs to by 
annotating them with presence conditions. 
For example, consider tuples
\ensuremath{\annot [\tFive] {(38, PL, 678)}}
and 
\ensuremath{\annot [\tFour] {(23, DB, \nul)}}
that belong to the \ecourse\ table. 
The presence conditions \tFive\ and \tFour\ state that tuples belong to temporal
variants four and five of this VDB, respectively.
Hence, this framework tracks which variants a tuple belongs to 
(first part of \nTwo).


%As shown, o
Our VDB framework encodes variation in databases 
at two levels: schema and content.
% We do not extend variation to 
%the constraint level and only focus on variation at the schema 
%and content levels. 
In a database that is a variational artifact as defined in \secref{req},
while content-level variation can stand on its own, such as
frameworks used for database versioning and 
experimental databases~\cite{dbVersioning},
the schema level cannot, e.g., 
\ensuremath{
\ecourse \left(\cno, \cname, \optAtt [\tFive] [\deptno] \right)^{\edu \wedge \left(\tFour \vee \tFive\right)}
} encodes variation at the schema level for relation \ecourse.
Dropping the presence conditions of tuples leads to ambiguity, i.e.,
it is unclear which variant each of the tuples
\ensuremath{(38, PL, 678)}
and 
\ensuremath{(23, DB, \nul)} belongs to. We can only guess that
they belong to variants where \tFour\ or \tFive\ are enabled, but, 
we do not know for sure which one.
\rewrite{rewrite this such that it says an example of how a framework can violate \nTwo\ is given
in \secref{vtab}. Thus, it violates the \nTwo\ 
requirement of a variational database framework.}
