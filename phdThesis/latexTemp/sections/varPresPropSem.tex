\subsection{Variation-Preserving Property at the Semantics Level}
\label{sec:var-pres-sem}

Since VDB contains multiple database variants
it is important that running a variational query over a  VDB  does not lose the variation 
encoded in a variational query and the VDB, that is, VRA's semantics
must also be variation-preserving. This is visualized in the diagram below,
where the vertical arrows indicate corresponding
%
% the code that produces the diagram
%\hspace{-2cm}
\begin{wrapfigure}{r}{0.24\textwidth}
\begin{center}
\begin{tikzcd}[column sep=2.3em]
  \constrain \vQ   \rar{\mathit{sem}}  \dar[swap,dashed]{\eeSem . }
& {\vTab}  \dar[dashed]{\otSem \vRelSch . } \\
  \pQ \rar{\underline{\mathit{sem}}}
& \pTab
\end{tikzcd}
\end{center}
\end{wrapfigure}
%
 configuration functions,
$\mathit{sem}$ indicates VRA's denotational semantics and 
$\underline{\mathit{sem}}$ indicates RA's denotational semantics. 
Note that $\mathit{sem}$ runs a variational query on a VDB and 
$\underline{\mathit{sem}}$ runs a relational query variant over its corresponding
configured relational database variant. 
%
Simply put, the configured variational table
resulting from running the variational query \vQ\ over the
VDB \vdbInst\ and variational schema \vSch\ with the configuration \config,  
$\otSem {\mathit{type} (\vQ, \vSch)} {\mathit{sem} (\vQ, \vdbInst)}$, 
must be the same as the relational table resulting from running the configured
relational query with configuration \config\ over its corresponding relational 
database, $\mathit{\underline{sem}} (\eeSem \vQ, \odbSem \vdbInst)$.
%
Clearly the diagram commutes: taking either path of 1) obtaining the 
semantics of the variational query \constrain \vQ\ first and then configuring it 
or 2)  configuring \constrain \vQ\ first and then getting its semantics
results in the same plain relational table. 
%
The variation-preserving property enforces the maintenance of variants that a 
tuple belongs to through running a query at the semantics level. 
%
This property follows from the denotational semantics of VRA since
we define VRA's denotational semantics in terms of RA's denotational semantics
by attaching either configurations of variants or feature expressions that denote
multiple configurations of variants to the relational queries. 

%To show that VRA is type safe we benefit from RA's type safety~\cite{RAtypeSys}
%by defining the \emph{variation-preserving} property for VRA which connects VRA to RA.
%%Variation-preserving property of VRA's type system and RA's type safety~\cite{RAtypeSys} 
%%implies that VRA's type system is also type safe.
%%Similar to other applications of variational research~\cite{CEW16ecoop,CEW14toplas},
%%the type system must preserve
%% the variation encoded in a variational query.
%%
%The 
%\emph{variation-preserving property with respect to variational schema} states that
%if a query \vQ\ has type \vType\ then 
%configuring the type of a valid explicitly annotated query
%is the same as the type of its configured
%corresponding query. 
%%
%\thmref{var-pres} proves this property.
%
%%, 
%%i.e., no matter which path the constrained query takes in the diagram it will results
%%to the same set of attributes.
%%
%% the code that produces the diagram
%%\hspace{-2cm}
%\begin{wrapfigure}{r}{0.24\textwidth}
%\begin{center}
%\begin{tikzcd}[column sep=2.3em]
%  \constrain \vQ   \rar{\mathit{type}}  \dar[swap,dashed]{\eeSem . }
%& {\annot \vType}  \dar[dashed]{\olSem . } \\
%  \pQ \rar{\underline{type}}
%& \pAttList
%\end{tikzcd}
%\end{center}
%\end{wrapfigure}
%%
%\thmref{var-pres} is visualized in the diagram below, where 
%the vertical arrows indicate corresponding configure functions,
%\ensuremath{\mathit{type}} indicates VRA's type system, 
%i.e., \ensuremath{\mathit{type}(\vQ) = \annot \vAttList} is 
%\ensuremath{\envWithoutVctx \vQ {\envInContext [ \vctx] \vType}},
%% of variational query \vQ\
%%generated by VRA's type system and 
%and
%\ensuremath{\underline{\mathit{type}}} indicates RA's type system,
%i.e., \ensuremath{\pEnv {\pQ} {\pAttList}}.
%%Note that for simplicity, w
%We assume that corresponding variation schema and schema is
%passed to type systems.
%% of relational query \pQ.
%Simply put, 
%the relational type of the configured variational query \vQ\ with configuration \config, 
%i.e., \ensuremath{\olSem {\mathit{type} (q)}},
%must be the same as the configured variational type 
%of the variational query \vQ\ with configuration \config, 
%i.e., \ensuremath{\underline {\mathit{type}} (\eeSem {\vQ})}.
%\emph{Clearly the diagram commutes}: taking either path of 1) configuring \constrain \vQ\ first and 
%then obtaining the relational type of it or 
%2) obtaining the variational type of \constrain \vQ\ first and then configuring it results
%in the same set of attributes. 
%The variation-preserving property enforces the maintenance of variants that a tuple
%belongs to through running a query at the schema level.%
%%, partially satisfying second part of 
%%\nTwo~
%\footnote{
%We define this property as a test at the semantics level and show that
%%We have not proved this property at the semantics level, however, 
%all our experimental
%queries passed it.}.
%%the test for variation-preserving property at the semantics level.}.
%%configuring a variational query \vQ\ for configuration \config\ first and then 
%%if we configure variational query \vQ\ for a given configuration \config\ its type (a set of attributes)
%%must be the same as if we generate the variational attribute set for
%%\vQ\ by VRA's type system and then configure it with \config,
%%
%%\appref{type-sys-prop-proof} sketches the proof of 
%%VRA's type system being variation-preserving.
%\exref{var-pres} illustrates why the query must be constrained by the variation schema
%in the variation-preserving diagram.
%
%\begin{theorem}
%\label{thm:var-pres}
%For all configurations \config, if a query \vQ\ has type \vType\ 
%then its configured query \ensuremath{\eeSem {\constrain \vQ}}
%has type \ensuremath{\olSem {\vType}}, i.e., \\
%\centerline{
%\ensuremath{
%\forall \config \in \confSet. \envWithoutVctx { \vQ} {\vType} \Rightarrow 
%\pEnv [\osSem {\vSch}] {\eeSem {\constrain \vQ}} {\olSem {\vType}}
%}}.
%\end{theorem}
%
%\begin{proof}
%By structural induction. We proved this theorem in the Coq proof assistant~\cite{FaribaThesis}.
%\end{proof}
%
%\eric{Eric, pls read this paragraph.}
%\thmref{var-pres} implies that for all valid configurations of a VDB, any variational
%query is correlated to a relational query and since RA is type safe its queries are
%type safe. Thus, variational queries are type safe. 
%
%\begin{example}
%\label{eg:var-pres}
%Consider the variational query 
%\ensuremath{\vQ_5 = \vPrj [{\vAtt_1, \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] \vRel} 
%given in \exref{conf-vq}. It is well-typed
%and  it has the type
%\ensuremath{\vAttList =
%\setDef {\optAtt [\fOne] [\vAtt_1], 
%\optAtt [\fOne \wedge \fTwo] [\vAtt_2], 
%\optAtt [\fTwo] [\vAtt_3]}
%}.
%Configuring \vAttList\ for the variant that both \fOne\ and \fTwo\ are disabled
%results is an empty attribute set. However, the type of its configured query
%for this variant, i.e., \ensuremath{\eeSem [\setDef \ ] {\vQ_5} =  \pi_{\pAtt_1} \pRel}, is the 
%attribute set \ensuremath{\setDef {\pAtt_1}}. This violates the
%variation-preserving property. A similar problem happens for the variant of
%\setDef {\fTwo}, i.e., \ensuremath{
%\underline{\mathit{type}} \left( \eeSem [\setDef \fTwo] {\vQ_5} \right) = 
%\underline{\mathit{type}} \left( \pi_{\pAtt_1, \pAtt_3} \pRel \right) = 
%\setDef{\pAtt_1, \pAtt_3} \not = \setDef{\pAtt_3} 
%= \olSem [\setDef \fTwo] {\vAttList}
%= \olSem [\setDef \fTwo] {\mathit{type} \left( \vQ_5 \right)}
%}. However, the variation-preserving property holds for the 
%constrained query by variation schema, i.e., 
%\ensuremath{
%\constrain [\vSch_3] {\vQ_5} = 
%\vPrj [{\optAtt [\fOne] [\vAtt_1], \optAtt [\fOne \wedge \fTwo] [\vAtt_2], \optAtt [\fTwo] [\vAtt_3]}] \vRel
%}.
%Thus, the input query to the configuration function \eeSem . \emph{must} be explicitly
%annotated by the underlying variation schema for the configured query to match the underlying 
%configured schema.
%%We can restrict VRA's type system to enforce users to incorporate the
%%variation schema into their queries, e.g., \ensuremath{\vQ_5} becomes
%%\ensuremath{\VVal \vQ_5 = 
%%\vPrj [{\optAtt [\fOne] [\vAtt_1], 
%%\optAtt [\fOne \wedge \fTwo] [\vAtt_2], 
%%\optAtt [\fTwo] [\vAtt_3]}] \vRel
%%}. However, one of the purposes of our type system is to relieve the users 
%%from having to encode the VDB's variability into their queries.
%%% this burdens the user to know the exact variation encoded in
%%%the database in addition to the original variation they want to encode in their query.
%%To avoid this violation without requiring users to repeat VDB's variability in their queries,
%%after type checking a query we push the variation schema onto the variational query,
%%e.g., doing so for \ensuremath{\vQ_5} results in \ensuremath{\VVal \vQ_5}.
%\end{example}
%
