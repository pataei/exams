\section{Future Work}
\label{sec:fw}

Since the long-term vision of this thesis is to support all kinds of variation
in databases, we can imagine many applications of VDB and VDBMS. A
measure of the success of this work will be if other researchers either use 
and configure VDBMS or pursue ideas in VDB to develop a new variation 
in databases framework  for different kinds of variation
in databases and especially for new kinds of variation in databases. 
%
However, in this section, we discuss a few immediate extensions and
improvements to the VDB that we plan on pursuing.

%\point{current limitations and future work.}
%\revised{
%Now we discuss limitations of our work in terms of possible improvements 
%as future work.
%}
As described in \secref{encode-var}, the VDB assumes a 
closed-world variation and configuration space, that is, the sets of features 
and configurations are closed. An immediate improvement is having an
open-world configuration space and then, an open-world feature space.
This would be a great improvement since it makes adding new database
variants and consequently, generating a VDB easier, resulting in a 
more accessible framework.
%It is important to note that we consider closed-world variation where
%all the database variants are known.

%
%We implemented basic SQL generators. They can be improved by 
%1) running SQL queries generated from a v-query in parallel and
%2) using common table expressions (CTEs) to store temporary
%results. We are planning to apply these optimizations.
%
As described in \chref{vdbms}, we implement presence conditions as strings, which is
inefficient because we need to manipulate every tuple's 
presence condition while running a 
query and then parsing it to a feature expression encoding to build the final
returning variational table. We plan to implement presence conditions as a 
user-defined data type inside the underlying DBMS engine, which
limits the engines that VDBMS can sit on top of them, as well as
defining user-defined functions over them that allow VDBMS to
manipulate them. 
%
Additionally, the performance of VDBMS can be improved different optimizations
such as clustering returned tuples based on their presence condition to reduce the
time it takes to filter out the tuples with unsatisfiable presence conditions. 

%
Furthermore, to make VDBMS more accessible and configurable to each 
kind of variation in databases we can generalize parts of it. For instance, 
we plan to generalize the feature expression such that its encoding and functions
can be defined by an expert of the specific kind of variation. This would allow
for context-specific optimizations with regards to the application domain 
of the kind of variation in databases.
%allow optimization for specific kind of variation in databases
%we plan to generalize feature such that one can define its specific encoding 
%and functions.
%expression so that it can be tailored toward a specific instance (e.g., schema evolution)
%of variation in databases by experts to make VDBMS more
%efficient for that instance.

%
Additionally, we plan to make VDBMS more useable by having a visual 
interface that shows a snapshot of the database as the user writes their
query. This would help the user understand the variation context of their 
query better and as they are writing their query, instead of waiting until 
they are done writing their query and then see if it passes the type system.
%
This improvement requires a type system that allows for holes in queries.
This can become richer by 
designing an error-tolerant type system that pinpoints
where the user made a mistake in their query and allows the part of
query that is well-typed to be run is beneficial when a query has lots of 
encoded variation within it. 
%\revised{
%Having such a type system also helps implementing a visual 
%assistance for writing queries gradually and with holes. Thus, a user
%can start writing part of their query and leave some parts blank and 
%see what tables and attributes they have at their disposal for each 
%left-out part. 
%}
%
%Allowing DBAs to use VDBMS easily requires a system that can 
%generate a VDB given plain relational database variants with their configurations
%attached to them and the v-schema encoding. We partially implemented
%this to generate the two use case VDBs. 
Finally, although we have not implemented a system to generate a VDB for 
a variational scenario it is trivial to do so if we have the variant databases.
The problem is that in most cases the variant databases do not exists
since current variational scenarios only simulate the effect of variation
and do not incorporate it directly into the database or queries.
Thus, an expert needs to manually generate the variant databases.
%
We plan to explore the possibilities of generating a VDB without 
having all database variants. This intertwines with moving from closed-world
variation and configuration space to open-world. 
%
Another way to go about this would be to extend the query language VRA 
to not only extract data from a VDB but also to define and manipulate data
in addition to extend database constraints to variational ones. 



%limitation: when applied in a specific context it may not be as efficient as
%the specific solutions but it's offering a new feature/property in dbs.
%e.g.:temporal changes, vq is more complicated and harder for user
%to write however it can be encoded differently! based on what the user
%needs. (all variants exists at a given time or only one variant is valid
%at a given time). 
%
%
%limitation: closed-world and not open world! i.e., all variants are already
%defined and encoded in the VDB.
%
%Extending feature expressions to a type class to allow for users
%to represent variability however they please. 
%
%An error-tolerant type system to forgive the variations of a v-query that 
%are type-ill but run the well-typed ones, instead of rejecting the whole
%v-query.
%
%As a result of our experiments we felt the pressing need of a 
%tool to generate VDBs from real world DBs and synthesized VDBs.
%
%future work:
%provenance.
%user defined type for feature expression instead of strings. and having
%user defined functions on them. and having sat solver inside DBMS.

