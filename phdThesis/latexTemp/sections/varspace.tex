\section{Variation Space in a Variational Database Framework}
\label{sec:varspace}

\TODO{have to revise}
\TODO{define oplus in fig as syntactic sugar.}

%\point{using a feature set to represent variability within a context.}
We encode variability in terms of \emph{features}.
%
The \emph{feature space}, \fSet, of a variational database
is a closed set of boolean variables called features.
%
A feature \ensuremath{\fName \in \fSet} can be enabled (i.e., \fName = \t) or disabled (\fName = \f).
Features describe the variability in a given variational scenario.
%first organize the configuration space into
%a set of features \fSet.
%, denoted by \fSet.
%
%we require a \emph{set of features}, denoted by \fSet, 
%appropriate for the context that the database is used for.
%
For example, in the context of schema evolution, features can be generated from version 
numbers (e.g., features \vOne\ to \vFive\ and \tOne\ to \tFive\ in the 
motivating example, \tabref{mot}); for SPLs, 
the features can be adopted from the SPL feature set (e.g., the \edu\ feature in
our motivating example, \tabref{mot}); and 
for data integration, the features may represent different data sources.  
%For simplicity, the set of features is assumed to be closed and features are
%assumed to be boolean variables, however, it is easy to extend them
%to multi-valued variables that have finite set of values.
% and without loss of generality, 
%features are assumed to be boolean variables, although, it is easy to extend them
%to multi-valued variables. 
%A feature \ensuremath{\fName \in \fSet} can be enabled (i.e., \fName = \t) or disabled (\fName = \f).
%\point{configuration.}
%Assuming that all the features by default are set to \prog{false},
%enabling some of them specifies a variant. 

Features are used at variation points to indicate which variants a particular
element belongs to.
%, i.e,
%in \fSet\ 
%are used to 
%they indicate which parts of the database are present conditionally.
%of a variational entity within the database 
%are different 
%among different variants. 
Thus, enabling or disabling each of
the features in the feature set
%in \fSet\ 
produces a particular database \emph{variant} where
%of the entity in which 
all variation has been removed. 
%Enabling or disabling all features of \fSet\ specifies a non-variational \emph{variant}
%that can potentially be generated by \emph{configur}ing its variational counterpart 
%with the variant's \emph{configuration}.
%Hence, to specify a variant
%we define a function, called 
A \emph{configuration} is a \emph{total} function
that maps every feature in the feature set to a boolean value.
%By definition, a configuration is a \emph{total} function,
%i.e., it is defined for \emph{all} features in the feature set. 
%For brevity, 
We represent a configuration by the set of enabled features.
%which represents a variant. 
%\ensure{make sure referring to a variant can be done by the set of enabled features. HERE!}
For example, in our motivating scenario, the configuration \ensuremath{
\setDef {\vTwo,\tThree,\edu}
}
represents a database variant where only features \vTwo, \tThree, and \edu\ are
enabled (and the rest are disabled).
This database variant contains relation schemas in the yellow cells of \tabref{mot}.
%of the
%employee and education sub-schemas associated with \vTwo\ and
%\tThree\ in \tabref{mot}, respectively.
%For brevity, 
We refer to a variant by the configuration that produces it, e.g.,
%For example, 
variant \setDef {\vTwo,\tThree,\edu} refers to the variant produced by applying
that configuration.
%and education sub-schema associated with \tThree\ in \tabref{mot}.

%\point{represent variability in db by prop formula of features, called feature expression.}
%Having defined a set of features, we need to incorporate them into the database.
%To encode features in the database, we construct propositional formulas of features
%such that the formula evaluates to \t\ for a set of configurations. 
When describing variation points in the database, we need to 
refer to subsets of the configuration space. We do this with
propositional formulas of features.
Thus, 
such a propositional formula defines a condition that holds for 
a subset of configurations and their corresponding variants. 
%
%describing the condition where one or more variants are present,
%i.e., assigning features to their values defined in variant's configuration and 
%evaluating the propositional formula results in \prog{true}.
%
For example, the propositional formula $\neg \edu$ represents all variants of
our motivating example where the $\edu$ feature is disabled, i.e., variant
schemas of the  left schema column. 
%
We call a propositional formula of features a \emph{feature expression} and define
it formally in \figref{fexp-def}. 
%\figref{fexp-def} defines the syntax of feature expressions.
The evaluation function of feature expressions 
$\fSem \dimMeta : \ffSet \to \confSet \to \bSet$ simply substitutes each
feature \fName\ in the expression \dimMeta\ with the boolean value 
given by configuration \config\ and then
simplifies the propositional formula to a boolean value.
%  evaluates the 
%feature expression \dimMeta\ w.r.t. the configuration \config.
%and defined in
%our technical report~\cite{vldbArXiv}, 
%and defined in \appref{fexp},
%evaluates feature expression \dimMeta\ under configuration \config,
%also called \emph{configuration of feature expression \dimMeta\ under \config}. 
For example, 
$\fSem [\{\A\}] {\A \vee \B} = \t \vee \f = \t$, while
%which states that the feature expression
%$\A \vee \B$ evaluates to \t\ w.r.t. configuration that only enables $\A$, however,
$\fSem [\{\}] {\A \vee \B} = \f \vee \f = \f$.
%, where the empty set indicates neither \A\ nor \B\
%are enabled.
%which states that the same feature expression evaluates
%to \f\ when neither $\A$ nor $\B$ are enabled.
Additionally, in \figref{fexp-def}, we define a binary \emph{equivalence
relation} ($\equiv$) relation on feature expressions corresponding to logical
equivalence, and unary \emph{sat} and \emph{unsat} predicates that determine
whether a feature expression is satisfiable or unsatisfiable, respectively.
%
% some of the functions needed over feature
%expressions:
%1) \emph{equivalence} of two feature expressions, 
%\ensuremath{\dimMeta_1 \equiv \dimMeta_2}
%and
%2) \emph{satisfiability} of a feature expression, 
%\ensuremath{\sat \dimMeta}.
%However, we define the evaluation of feature expressions and functions over them
%in \appref{fexp}.
%We define two functions over feature expressions, as shown in \figref{fexp-def}:
%1) \emph{satisfiability}: feature expression \dimMeta\ is \emph{satisfiable} if there 
%exists configuration \config\ s.t. \fSem \dimMeta = \t\
%and 2) \emph{tautology}: feature expression \dimMeta\ is a \emph{tautology} if  
%for all valid configurations we have: \fSem \dimMeta = \t.

%\point{annotating elements of database with feature expressions.}
To incorporate feature expressions into the database,
we \emph{annotate} database elements (including attributes, relations, and tuples) 
with feature expressions. An \emph{annotated element} \elem\ with feature expression \dimMeta\
is denoted by \annot \elem. 
%The feature expression \dimMeta\ represents
%the set of configurations where their variants contain element \elem\ because
%
The feature expression attached to an element is called its \emph{presence
condition} since it determines the condition (set of configurations) under
which the element is present in the database. For example, assuming
$\ffSet=\set{\A,\B}$, the annotated number $\annot [\A \vee \B] 2$ is present
in variants \setDef{\A}, \setDef{\B}, and \setDef{\A,\B} but not in variant
\setDef{}.
%
The operation $\getPC{\annot{\elem}}=e$ returns the presence condition of an
annotated element.
% with a configuration
%that enables either $\A$ or $\B$ or both
%variants that disable both $\A$ and $\B$.
% Here, $\getPC {\annot [\A \vee \B] 2} = \A \vee \B$.

%\point{relationship between features is captured by a propositional formula, called feature model.} 
No matter the context, features often have a relationship with each other that
constrains the set of possible configurations. For example, only one of the
temporal features of \vOne--\vFive\ can be \t\ for a given variant. This
relationship is captured by a feature expression, called a \emph{feature model}
and denoted by \fModel, which restricts the set of \emph{valid configurations}.
That is, a configuration $c$ is only valid if $\fSem{\fModel}=\t$.
%
For example, the restriction that at a given time only one of temporal features
\vOne--\vFive\ 
can be enabled is represented by the feature model
$\vOne \oplus \vTwo \oplus \vThree \oplus \vFour \oplus \vFive$,
where $\A \oplus \B \oplus \ldots \oplus \fName_n$ is syntactic sugar for
$(\A \wedge \neg \B \wedge \ldots \wedge \neg \fName_n)
\vee (\neg \A \wedge \B \wedge \ldots \wedge \neg \fName_n)
\vee (\neg \A \wedge \neg \B \wedge \ldots \wedge \fName_n)$,
that is, the features are mutually exclusive.
%multiple features cannot be enabled simultaneously.
%$\left(\vOne \wedge \neg \left(\vTwo \vee \hdots \vee \vFive \right) \right)
%\vee \left(\vTwo \wedge \neg \left(\vOne \vee \vThree \vee \vFour \vee \vFive \right) \right) 
%\vee \hdots 
%\vee \left(\vFive \wedge \neg \left(\vOne \vee \hdots \vee \vFour \right) \right)$.
%Note that this is not the feature model for the entire motivating example.



\input{formulas/fexpDef}
\input{formulas/fexpEval}


