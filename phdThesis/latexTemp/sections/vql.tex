\chapter{Variational Queries}
\label{ch:vql}

\rewrite{change all $\vFour \vee \vFive$ to $\neg \vThree$ in all sections and
update the derivation tree examples to the final type system. }

\eric{pls read the following paragraph}
Now that we have introduced the variational database framework 
we need a query language to extract information from a VDB instance
and unlike relational query languages (like SQL and relational algebra)
it needs to account for the new aspect of our database: variation. 


%\point{queries need to be able to express variability encoded in vdb.}
%The variational nature of a VDB requires a query language that
%accounts for variation directly.
%To express and represent variation in queries,
%we incorporate choice calculus~\cite{Walk13thesis, EW11tosem}  into a 
%structured query language. 
We formally define 
\emph{variational relational algebra} (VRA) in \secref{vrel-alg}
as our algebraic query language.
A query written in VRA is called a \emph{variational query} (\emph{v-query});
we use query and variational query interchangeably when it is clear from context. 
Unlike relational queries that convey an intent over a single database, 
a variational query typically conveys the same intent over several 
relational database variants. However, a single variational query is also capable of capturing different 
intents over different database variants.
%Consequently, the expressiveness of variational queries may cause them to be 
%more complicated than relational queries, discussed in \secref{type-sys}. 
%Hence, 

\eric{pls read the following paragraph}
To understand the meaning of variational queries
we define the semantics of variational queries via the
semantics of relational queries in \secref{vrasem}. We define
approaches to configure a variational query to a relational query
in \secref{vraconf}. Then, we use the results of multiple relational
queries to accumulate the result of the original variational query 
in \secref{accum}.
%\maybeAdd{add direct sem of VRA if time allows and equiv in vql prop.}

Due to the expressiveness of variational queries, 
we define a type system for VRA that statically checks a
variational query against the underlying variational schema in \secref{type-sys}.
%
To make variational queries more useable we relieve the user from repeating 
the variational schema's variation in their variational queries. This is achieved by 
explicitly annotating queries in \secref{constrain}.
%In \secref{constrain}, we define an operation that explicitly annotates a
%variational query with information contained in a v-schema. 
%This operation is useful to
%define the \emph{variation-preservation} property for VRA and its type system,
%which is discussed in \secref{var-pres}, and demonstrates how our framework
%satisfies the information need \nTwo.
We then define the \emph{variation-preservation} property for VRA at
the type level in \secref{var-pres}.
% which proves that our framework
%satisfies the requirement \nTwo.
%
Finally, we provide 
%we close out this section by providing 
a set of syntactic rules that are semantic-preserving 
in \secref{var-min} that enable factoring and distributing
variation points within a variational query, which enables syntactic refactorings
including maximizing sharing within a variational query.
%for reducing a query's variation.


\input{sections/vra}
%\input{sections/typesys}
\input{sections/vrasem}
\input{sections/vra2ra}
\input{sections/accum}
\input{sections/vradensem}
\input{sections/typesys}
\input{sections/constrainVQbySch}
\input{sections/vminrule}
\input{sections/vqlprop}
%if time allows have a subsection for properties of the equivalnece of dent sem and ra + accum

