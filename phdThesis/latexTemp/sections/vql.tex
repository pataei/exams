\chapter{Variational Queries}
\label{ch:vql}

%change all $\vFour \vee \vFive$ to $\neg \vThree$ in all sections and
%update the derivation tree examples to the final type system. }

Now that we have introduced the variational database framework 
we need a query language to extract information from a VDB instance.
Our approach will build on existing relational query languages (like SQL and relational algebra)
but must also account for the new aspect of our database: variation. 


%\point{queries need to be able to express variability encoded in vdb.}
%The variational nature of a VDB requires a query language that
%accounts for variation directly.
%To express and represent variation in queries,
%we incorporate choice calculus~\cite{Walk13thesis, EW11tosem}  into a 
%structured query language. 
We formally define 
\emph{variational relational algebra} (VRA) in \secref{vrel-alg}
as our algebraic query language.
A query written in VRA is called a \emph{variational query} (\emph{v-query});
we use query and variational query interchangeably when it is clear from context. 
Unlike relational queries that convey an intent over a single database, 
a variational query typically conveys the same intent over several 
relational database variants. However, a single variational query is also capable of capturing different 
intents over different database variants.
%Consequently, the expressiveness of variational queries may cause them to be 
%more complicated than relational queries, discussed in \secref{type-sys}. 
%Hence, 



%
Due to the expressiveness of variational queries, 
we define a type system for VRA that statically checks a
variational query against the underlying variational schema in \secref{type-sys}.
%
To make variational queries more useable we relieve the user from repeating 
the variational schema's variation in their variational queries. This is achieved by 
explicitly annotating queries in \secref{constrain}.
%In \secref{constrain}, we define an operation that explicitly annotates a
%variational query with information contained in a v-schema. 
%This operation is useful to
%define the \emph{variation-preservation} property for VRA and its type system,
%which is discussed in \secref{var-pres}, and demonstrates how our framework
%satisfies the information need \nTwo.

To understand the meaning of variational queries
we define the semantics of variational queries via the
semantics of relational queries in \secref{vrasem}. We define
how to configure a variational query to a relational query
in \secref{vraconf}. Then, we use the results of multiple relational
queries to accumulate the result of the original variational query 
in \secref{accum}.
%\maybeAdd{add direct sem of VRA if time allows and equiv in vql prop.}


%
We also provide 
%we close out this section by providing 
a set of syntactic rules that are semantic-preserving 
in \secref{var-min}. These rules enable factoring and distributing
variation points within a variational query, which enables syntactic refactoring
including maximizing sharing within a variational query.
%for reducing a query's variation.
%
Finally, in \secref{vqlprop}, we present some properties of the VRA including
the expressiveness and type safety of VRA in \secref{express} and \secref{var-pres}, respectively,
in addition to the \emph{variation-preservation} property of VRA at the
semantics level in \secref{var-pres-sem}.
%also define the \emph{variation-preservation} property for VRA at
%the type level in \secref{var-pres}.


\input{sections/vra}
%\input{sections/typesys}
\input{sections/typesys}
\input{sections/constrainVQbySch}
\input{sections/vrasem}
\input{sections/vra2ra}
\input{sections/accum}
\input{sections/vradensem}
\input{sections/vminrule}
\input{sections/vqlprop}
%if time allows have a subsection for properties of the equivalnece of dent sem and ra + accum

